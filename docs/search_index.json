[["index.html", "Python For Data Science Acknowledgement", " Python For Data Science Davut Ayan 2024-09-02 Acknowledgement This is a personal notebook open for public use. I have collected these notes, codes and best practices that I find useful to teach myself on python programming language. All these content are free to use and share. knitr::opts_chunk$set(error = TRUE) "],["intro.html", "Chapter 1 Introduction 1.1 Basics 1.2 Collections 1.3 Data Types 1.4 Control Statements 1.5 Functions", " Chapter 1 Introduction Python Python is what is called an interpreted language. Compiled languages examine your entire program at compile time, and are able to warn you about a whole class of errors prior to execution. In contrast, Python interprets your script line by line as it executes it. Python will stop executing the entire program when it encounters an error (unless the error is expected and handled by the programmer, a more advanced subject that we’ll cover later on in this course). Jupyter Lab to install on mac: pip3 install jupyterlab on terminal to upgrade pip: pip3 install --upgrade pip on terminal check python version !python -V # Check the Python Version import sys print(sys.version) ## 3.10.3 (v3.10.3:a342a49189, Mar 16 2022, 09:34:18) [Clang 13.0.0 (clang-1300.0.29.30)] [Tip:] sys is a built-in module that contains many system-specific parameters and functions, including the Python version in use. Before using it, we must explicitly import it. In Python, the concepts of objects and data types are closely related. In fact, in Python, everything is an object. Understanding this relationship is key to working effectively with Python. 1.1 Basics 1.1.1 Data Types in Python Type of an Object: The type of an object in Python represents the kind of data that the object can hold. For example, the types int, float, str, etc., represent different categories of data. Type Checking: You can use the type() function to determine the type of an object. For example: x = 5 print(type(x)) # Output: &lt;class &#39;int&#39;&gt; Dynamic Typing: Python is dynamically typed, which means you don’t have to explicitly declare the type of a variable. The type is determined at runtime. 1.1.2 Objects vs Data Types Every value in Python is an object, and every object has a type. For example, 5 is an object of type int. Data types in Python are essentially classes, and objects are instances of those classes. When you create a variable, you are creating an instance of a specific data type (class). You can think of data types as categories or blueprints for objects. They define the behavior and characteristics of objects. 1.1.3 Objects in Python Everything is an Object: In Python, every value is an object, and every object has a type. This includes not only the fundamental data types (integers, floats, strings) but also more complex types like lists, dictionaries, and even functions. Object Identity: Each object in Python has a unique identity, which can be obtained using the id() function. This identity is guaranteed to be unique and constant for the lifetime of the object. Object Attributes and Methods: Objects in Python can have attributes (characteristics) and methods (functions associated with the object). For example, a string object has methods like upper() and attributes like length. In Python, everything is an object. Objects are instances of classes, and Python is an object-oriented programming language. Here are some common types of objects in Python: Numbers: int: Integer type, e.g., x = 5. float: Floating-point type, e.g., y = 3.14. complex: Complex number type, e.g., z = 2 + 3j. Strings: str: String type, e.g., s = \"Hello, World!\". Collections: list: Ordered collection of items, e.g., my_list = [1, 2, 3]. tuple: Immutable ordered collection of items, e.g., my_tuple = (1, 2, 3). set: UNORDERED, MUTABLE collection of unique items, e.g., my_set = {1, 2, 3}. dict: Key-value pairs, e.g., my_dict = {'a': 1, 'b': 2}. List vs Tuple: - both ordered - tuple is IMMUTABLE Boolean: bool: Boolean type, representing True or False. x = True y = False print(type(x)) # &lt;class &#39;bool&#39;&gt; None: None: A special object representing the absence of a value or a null value. x = None print(type(x)) # &lt;class &#39;NoneType&#39;&gt; Functions: Functions themselves are objects in Python. You can assign them to variables, pass them as arguments, and return them from other functions. Classes: User-defined classes create objects. Instances of a class are objects. Modules: Modules are also objects. When you import a module, you are working with an object. File Objects: When you open a file, the file itself is an object in Python. Exceptions: Exception instances are objects that represent exceptional conditions. Custom Objects: Objects created from user-defined classes. In Python, you can use the type() function to determine the type of an object, and the isinstance() function to check if an object is an instance of a particular class. The dynamic typing nature of Python allows objects to change types during runtime. There are many different types of objects in Python. Let’s start with the most common object types: strings, integers and floats. Anytime you write words (text) in Python, you’re using character strings (strings for short). The most common numbers, on the other hand, are integers (e.g. -1, 0, 100) and floats, which represent real numbers (e.g. 3.14, -42.0). 1.2 Collections list: Ordered collection of items, e.g., my_list = [1, 2, 3]. tuple: Immutable ordered collection of items, e.g., my_tuple = (1, 2, 3). set: Unordered collection of unique items, e.g., my_set = {1, 2, 3}. dict: Key-value pairs, e.g., my_dict = {'a': 1, 'b': 2}. 1.2.1 Properties In Python, collections are built-in data types that can be used to group multiple elements together. Here are some common properties of Python collections: 1.2.1.1 Mutable vs. Immutable: Mutable Collections: Lists (list), Sets (set), and Dictionaries (dict) are mutable. You can modify their contents after creation. Immutable Collections: Tuples (tuple) and Strings (str) are immutable. Once created, their contents cannot be changed. 1.2.1.2 Ordering: Ordered Collections: Lists and Tuples maintain the order of elements. Elements are stored in the order they were added. Unordered Collections: Sets and Dictionaries do not guarantee any specific order. The order of elements may not be the same as the order of insertion. 1.2.1.3 Indexing and Slicing: Indexing: Lists, Tuples, and Strings support indexing. Elements can be accessed using indices (0-based). my_list = [1, 2, 3, 4] print(my_list[0]) # Output: 1 Slicing: Lists, Tuples, and Strings support slicing to create sub-collections. my_string = &quot;Hello, World!&quot; print(my_string[0:5]) # Output: Hello 1.2.1.4 Uniqueness: Unique Elements: Sets only contain unique elements. If you try to add an element that already exists, it won’t be added again. my_set = {1, 2, 3, 1} print(my_set) # Output: {1, 2, 3} 1.2.1.5 Key-Value Pairs (Dictionaries): Associative Data: Dictionaries consist of key-value pairs, allowing you to associate values with unique keys. my_dict = {&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 30, &#39;city&#39;: &#39;New York&#39;} print(my_dict[&#39;age&#39;]) # Output: 30 1.2.1.6 Heterogeneity: Mixed Types: Lists, Tuples, and Sets can contain elements of different data types. my_list = [1, &#39;apple&#39;, 3.14] 1.2.1.7 Using append() for a Single Element: list_1 = [1, 2, 3] list_1.append(10) # do not assign to a variable print(list_1) ## [1, 2, 3, 10] 1.2.1.8 Using extend() for Multiple Elements: list_2 = [1, 2, 3] list_2.extend( [10, 100, 1000] ) # requires a list print(list_2) ## [1, 2, 3, 10, 100, 1000] 1.2.1.9 Using add() for set objects: set_3 = {1, 2, 3} set_3.add( 100 ) # requires a list print(set_3) ## {1, 2, 3, 100} Removing Elements: remove(), pop(), discard(), clear() 1.2.1.10 remove() Method Purpose: Removes the first occurrence of a specified value from a list or set. Usage: For lists, if the specified value does not exist, it raises a ValueError. For sets, it also raises a KeyError if the specified value is not present. my_list = [1, 2, 3, 2, 4] # Removes the first occurrence of 2 my_list.remove(2) print(my_list) ## [1, 3, 2, 4] 1.2.1.11 pop() Method Purpose: Removes and returns an element from a list or set. Usage: For lists, it removes and returns the element at a specified index. If no index is provided, it removes and returns the last element. Raises an IndexError if the list is empty. For sets, it removes and returns an arbitrary element because sets are unordered. Raises a KeyError if the set is empty. my_list = [1, 2, 3, 4] # Removes and returns the last element by default last_element = my_list.pop() print(last_element) # Output: 4 ## 4 print(my_list) # Output: [1, 2, 3] ## [1, 2, 3] # Removes and returns the element at index 1 second_element = my_list.pop(1) print(second_element) # Output: 2 ## 2 print(my_list) # Output: [1, 3] ## [1, 3] 1.2.1.12 discard() Method Purpose: Removes the specified element from a set. Usage: Sets only: Does not raise an error if the specified element does not exist, unlike remove(). my_set = {1, 2, 3} # Discards the element 2 my_set.discard(2) print(my_set) # Output: {1, 3} ## {1, 3} 1.2.1.13 clear() Method Purpose: Removes all elements from a list or set, making it empty. Usage: Can be used with both lists and sets to empty them. my_list = [1, 2, 3] # Clears all elements from the list my_list.clear() print(my_list) ## [] 1.2.1.14 Extra: Imuutable Yes, in Python, strings are immutable objects. This means that once a string is created, you cannot change its content. Any operation that appears to modify a string actually creates a new string. This immutability has several implications: No In-Place Modifications: You cannot modify a string directly by changing a character at a specific index, like you can with a list. my_string = &quot;Hello&quot; # The following will result in an error my_string[0] = &#39;J&#39; Creating New Strings: Operations like concatenation or slicing create new strings rather than modifying the original. original_string = &quot;Hello&quot; new_string = original_string + &quot;, World!&quot; Hashing: Because strings are immutable, they can be used as keys in dictionaries and elements in sets. Their hash value remains constant. my_set = {&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;} Memory Efficiency: Python can optimize memory usage by reusing the same string in memory if it already exists, thanks to immutability. a = &quot;Hello&quot; b = &quot;Hello&quot; # Both a and b refer to the same string object in memory Understanding the immutability of strings is important when working with them in Python to avoid unexpected behavior and to write efficient and correct code. If you need to modify a string, you typically create a new string with the desired changes. 1.2.2 1. lists A list is a sequenced collection of different objects such as integers, strings, and even other lists as well. The address of each element within a list is called an index. An index is used to access and refer to items within a list. Lists can contain strings, floats, and integers. We can nest other lists, and we can also nest tuples and other data structures. The same indexing conventions apply for nesting: list are like tuples, ordered sequences. But lists are mutable. A list is a built-in data type used to store an ordered collection of items. Lists are mutable, which means you can modify their contents by adding, removing, or changing elements. Lists are defined using square brackets []. Here’s an overview of lists and some example methods: 1.2.2.1 Creating Lists: x = [] ## empty list y = [1, 2, 3, &#39;apple&#39;, &#39;banana&#39;, &#39;cherry&#39;] z = list( a_array) 1.2.2.2 Common List Methods: Accessing # Accessing by index my_list[0] # Result: 1 ## list index out of range # Slicing my_list[1:4] # Result: [2, 3, &#39;apple&#39;, &#39;banana&#39;] ## [] Append (append()): Adds an element to the end of the list. my_list.append(&quot;XXXX&quot;) print(my_list) ## [&#39;XXXX&#39;] Extend (extend()): Extends the list by appending elements from another iterable. another_list = [5, 6, 7] my_list.extend(another_list) print(my_list) ## [&#39;XXXX&#39;, 5, 6, 7] Insert (insert()): Inserts an element at a specified position. this is not replacing !!! my_list.insert(2, &#39;orange&#39;) print(my_list) ## [&#39;XXXX&#39;, 5, &#39;orange&#39;, 6, 7] Remove (remove()): Removes the first occurrence of a specified value. my_list.remove(&#39;banana&#39;) ## list.remove(x): x not in list print(my_list) ## [&#39;XXXX&#39;, 5, &#39;orange&#39;, 6, 7] Pop (pop()): Removes and returns the element at the specified index. If no index is provided, it removes the last element. popped_element = my_list.pop(2) print(popped_element) ## orange Index (index()): Returns the index of the first occurrence of a specified value. index_of_apple = my_list.index(&#39;apple&#39;) ## &#39;apple&#39; is not in list print(index_of_apple) ## name &#39;index_of_apple&#39; is not defined Count (count()): Returns the number of occurrences of a specified value. count_of_cherry = my_list.count(&#39;cherry&#39;) print(count_of_cherry) ## 0 Sort (sort()): Sorts the list in ascending order. Optionally, you can specify reverse=True for descending order. # Convert all elements to strings before sorting st_list = [str(x) for x in my_list] st_list.sort() print(st_list) ## [&#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;XXXX&#39;] # Convert all elements to strings before sorting sorted_list = sorted(map(str, my_list)) print(sorted_list) ## [&#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;XXXX&#39;] Reverse (reverse()): Reverses the order of the elements in the list. my_list.reverse() print(my_list) ## [7, 6, 5, &#39;XXXX&#39;] Concatenate lists a_list = [1, 2, 3] b_list = [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;] print(a_list + b_list) ## [1, 2, 3, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;] loop thru a list a = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] for item in a: print(item.upper()) ## A ## B ## C 1.2.3 tuples Tuples are an ordered sequences of items, just like lists. The main difference between tuples and lists is that tuples cannot be changed (immutable) unlike lists which can (mutable). tuples are collection of different type of objects. Empty tuples a = () b = tuple() Create tuples ## 1. way a_tuple = (1, 2.5, &quot;string&quot;, [3, 4]) b = (1,) print(b) ## (1,) Concatenate tuples b_tuple = (&quot;a&quot;, &quot;ab&quot;) print(a_tuple + b_tuple) ## (1, 2.5, &#39;string&#39;, [3, 4], &#39;a&#39;, &#39;ab&#39;) Immutable element of a tuple can not be changed a_tuple = (1,2,3,4,5) a_tuple[5] = &quot;a&quot; # TypeError: &#39;tuple&#39; object does not support item assignment sorted function sorted() function: We can sort the tuple and assign a new name sorted() function returns list type. a_tuple = (1, 5, 2, 7, 4) x = sorted(a_tuple) print(x) ## [1, 2, 4, 5, 7] Nesting we can create nested tuples. nested = (1, 2, (&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), (&quot;ayan&quot;, (4, 5))) nested[2] ## (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;) 1.2.3.1 tuple methods index method The index method returns the first index at which a value occurs. a = (&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) a.index(&quot;c&quot;) ## 2 count method The count method returns the number of times a value occurs in a tuple. a = (&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;b&quot;) a.count(&quot;b&quot;) ## 3 loop thru a tuple a = (&quot;a&quot;, &quot;b&quot;, &quot;a&quot;, &quot;b&quot;) for item in a: print(item) ## a ## b ## a ## b 1.2.4 Sets Sets in Python are unordered collections of unique elements. Unlike lists, sets do not have a specific order, and each element in a set must be unique. Here are some common operations and methods associated with sets: Creating Sets my_set = {1, 2, 3, 4, 5} Adding Elements my_set.add(6) # Adds the element 6 to the set Removing Elements my_set.remove(3) # Removes the element 3 from the set Set Operations set1 = {1, 2, 3, 4, 5} set2 = {3, 4, 5, 6, 7} # Union union_set = set1.union(set2) # Result: {1, 2, 3, 4, 5, 6, 7} # Intersection intersection_set = set1.intersection(set2) # Result: {3, 4, 5} # Difference difference_set = set1.difference(set2) # Result: {1, 2} # Symmetric Difference symmetric_difference_set = set1.symmetric_difference(set2) # Result: {1, 2, 6, 7} 1.2.4.1 Set Methods # Discard an element (if it exists) my_set.discard(4) # Clear all elements my_set.clear() # Copying a set copy_of_set = my_set.copy() Other Operations # Checking Membership is_present = 5 in my_set # Result: True # Length of a Set length_of_set = len(my_set) Sets are useful when you need to work with unique elements, perform set operations, or check for membership efficiently. They do not support indexing or slicing, as they are unordered. Additionally, sets are mutable, meaning you can add and remove elements, but individual elements must be immutable (e.g., numbers, strings). 1.2.5 Dictionary Dictionaries in Python are collections of key-value pairs, where each key must be unique. Dictionaries are versatile and used for mapping values to unique keys. Here are common operations and methods associated with dictionaries: Creating Dictionaries my_dict = {&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 30, &#39;city&#39;: &#39;New York&#39;} print(my_dict) ## {&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 30, &#39;city&#39;: &#39;New York&#39;} Accessing Values # Accessing by key p0 = my_dict[&#39;name&#39;] # Result: &#39;John&#39; print(p0) ## John # Using the get() method p1 = my_dict.get(&#39;name&#39;) # Result: 30 print(p1) ## John Modifying Dictionaries # Updating a value my_dict[&#39;age&#39;] = 31 # Adding a new key-value pair my_dict[&#39;gender&#39;] = &#39;Male&#39; Removing Items # Removing a key-value pair del my_dict[&#39;city&#39;] my_dict = {&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 30, &#39;gender&#39;: &#39;Male&#39;} # Using the pop() method gender = my_dict.pop(&#39;gender&#39;) # Removes the &#39;gender&#39; key and returns its value print(gender) ## Male 1.2.5.1 Dictionary Methods: # Getting all keys keys = my_dict.keys() # Result: [&#39;name&#39;, &#39;age&#39;] print(keys) ## dict_keys([&#39;name&#39;, &#39;age&#39;]) # Getting all values values = my_dict.values() # Result: [&#39;John&#39;, 31] print(values) ## dict_values([&#39;John&#39;, 30]) # Getting all key-value pairs as tuples items = my_dict.items() # Result: [(&#39;name&#39;, &#39;John&#39;), (&#39;age&#39;, 31)] print(items) ## dict_items([(&#39;name&#39;, &#39;John&#39;), (&#39;age&#39;, 30)]) 1.2.6 Iterating Over a Dictionary: for key in my_dict: print(key, my_dict[key]) ## name John ## age 30 1.2.7 Other Operations: # Checking Membership (in terms of keys) is_present = &#39;age&#39; in my_dict # Result: True # Length of a Dictionary length_of_dict = len(my_dict) Dictionaries are widely used in Python for tasks that involve mapping keys to values, such as representing data structures, configuration settings, and more. They are mutable, meaning you can modify their contents by adding, updating, or removing key-value pairs. The keys must be immutable (e.g., strings, numbers), but the values can be of any type. 1.3 Data Types In Python, data types are classifications that specify which type of value a variable can hold. Here are some of the basic and commonly used data types in Python: Numeric Types: int: Integer type, e.g., x = 5. float: Floating-point type, e.g., y = 3.14. complex: Complex number type, e.g., z = 2 + 3j. Text Type: str: String type, e.g., s = \"Hello, World!\". Sequence Types: list: Ordered collection of items, e.g., my_list = [1, 2, 3]. tuple: Immutable ordered collection of items, e.g., my_tuple = (1, 2, 3). Set Types: set: Unordered collection of unique items, e.g., my_set = {1, 2, 3}. frozenset: Immutable version of a set. Mapping Type: dict: Dictionary, a collection of key-value pairs, e.g., my_dict = {'a': 1, 'b': 2}. Boolean Type: bool: Boolean, representing True or False. None Type: NoneType (None): A special type representing the absence of a value or a null value. Binary Types: bytes: Immutable sequence of bytes, e.g., b = b'hello'. bytearray: Mutable sequence of bytes. memoryview: A view object that exposes an array’s buffer interface. These data types are the building blocks for creating variables, structures, and performing various operations in Python. You can use the type() function to check the type of a variable or value. For example: x = 5 print(type(x)) # Output: &lt;class &#39;int&#39;&gt; y = 3.14 print(type(y)) # Output: &lt;class &#39;float&#39;&gt; s = &quot;Hello, World!&quot; print(type(s)) # Output: &lt;class &#39;str&#39;&gt; Understanding and working with these data types is fundamental to writing Python code. Keep in mind that Python is dynamically typed, meaning you don’t need to explicitly declare the data type of a variable; it is determined at runtime. 1.3.1 Numeric Types 1.3.1.1 Mathematical Operations Python supports a variety of mathematical operations, which can be performed on numerical data types. Here are some common mathematical operations in Python: 1.3.1.2 Arithmetic Operations: Addition (+): result = 5 + 3 # result is 8 Subtraction (-): result = 5 - 3 # result is 2 Multiplication (*): result = 5 * 3 # result is 15 Division (/): result = 6 / 3 # result is 2.0 (float) Floor Division (//): result = 7 // 3 # result is 2 (integer division) Modulus (%): result = 7 % 3 # result is 1 (remainder after division) Exponentiation (**): result = 2 ** 3 # result is 8 (2 to the power of 3) 1.3.1.3 Comparison Operations: Equal to (==): result = (5 == 3) # result is False Not equal to (!=): result = (5 != 3) # result is True Greater than (&gt;): python result = (5 &gt; 3) # result is True Less than (&lt;): python result = (5 &lt; 3) # result is False Greater than or equal to (&gt;=): python result = (5 &gt;= 3) # result is True Less than or equal to (&lt;=): python result = (5 &lt;= 3) # result is False 1.3.2 Other Mathematical Functions: Absolute Value (abs()): python result = abs(-5) # result is 5 Round (round()): python result = round(3.14159, 2) # result is 3.14 (rounded to 2 decimal places) Minimum (min())/Maximum (max()): python minimum = min(1, 2, 3) # minimum is 1 maximum = max(1, 2, 3) # maximum is 3 These are just a few examples, and Python provides a rich set of mathematical functions and operations through the math module as well. To use it, you can import the math module and access functions like math.sqrt(), math.sin(), math.cos(), etc. import math # Square root result = math.sqrt(16) # result is 4.0 # Trigonometric functions (input in radians) sin_result = math.sin(math.radians(30)) # result is 0.5 (sin of 30 degrees) cos_result = math.cos(math.radians(60)) # result is 0.5 (cos of 60 degrees) tan_result = math.tan(math.radians(45)) # result is 1.0 (tan of 45 degrees) # Logarithmic functions log_result = math.log(100, 10) # result is 2.0 (log base 10 of 100) # Exponential function exp_result = math.exp(2) # result is approximately 7.389 # Constants pi_value = math.pi # value of pi (3.141592653589793) euler_number = math.e # Euler&#39;s number (2.718281828459045) # Other functions factorial_result = math.factorial(5) # result is 120 (5!) 1.3.3 Converting data types numeric to string a = 5.5 b = str(a) string to numeric float(&quot;1.1&quot;) ## 1.1 it does not convert directly to integer here int(&quot;1.123&quot;) but it works when transforming to float then integer. int(float(&quot;10.123&quot;)) boolean to numeric True becomes 1 bl = True int(bl) ## 1 numeric to boolean 0 becomes False all other numbers are True bool(-100) ## True bool(0) ## False 1.3.4 Strings A string is a sequence of characters, and it is one of the basic data types used to represent text. Strings are enclosed in either single quotes (') or double quotes (\"), and you can use either as long as the opening and closing quotes match. Here are some key characteristics and operations related to strings in Python: Creating Strings # Using single quotes single_quoted_string = &#39;Hello, Python!&#39; # Using double quotes double_quoted_string = &quot;Hello, Python!&quot; # Triple-quoted strings for multiline strings multiline_string = &#39;&#39;&#39;This is a multiline string.&#39;&#39;&#39; String Concatenation first_name = &quot;John&quot; last_name = &quot;Doe&quot; full_name = first_name + &quot; &quot; + last_name print(full_name) ## John Doe String Indexing and Slicing my_string = &quot;Python&quot; # Indexing (0-based) first_char = my_string[0] # Result: &#39;P&#39; print(first_char) ## P syntax: string_object[from : to : increment] # Slicing substring = my_string[1:4:1] # Result: &#39;yth&#39; substring = my_string[1:4] # Result: &#39;yth&#39; print(substring) ## yth print(my_string[::2]) ## Pto 1.3.4.1 String Methods: # Length of a string length = len(my_string) # Result: 6 # Converting to uppercase and lowercase uppercase_string = my_string.upper() lowercase_string = my_string.lower() # Finding a substring index_of_th = my_string.find(&quot;th&quot;) # Result: 2 # Replacing a substring new_string = my_string.replace(&quot;on&quot;, &quot;er&quot;) # Result: &#39;Pyther&#39; upper() : strings to uppercase lower() : strings to lowercase capitalize() : strings to uppercase 1st letter &quot;Ohh! my life!&quot;.upper() ## &#39;OHH! MY LIFE!&#39; &quot;OHH! MY LIFE!&quot;.lower() ## &#39;ohh! my life!&#39; &quot;star&quot;.capitalize() ## &#39;Star&#39; &quot;is it lowercase&quot;.islower() ## True &quot;IS IT UPPERCASE&quot;.isupper() ## True replace method replace(): to replace part of a string syntax: string.replace(oldvalue, newvalue, count) query = &#39;&#39;&#39; select all_columns from my_table &#39;&#39;&#39; new_query = query.replace(&quot;my_table&quot;, &quot;new_table_name&quot;) print(new_query) ## ## select all_columns ## from new_table_name strip method strip() method removes leading or trailing white-space raw_text = &quot; my text &quot; raw_text.strip() ## &#39;my text&#39; split method split() method breaks a string by specified character. split() method returns list type. raw_text = &quot;banana, apple, cherry&quot; alist = raw_text.split(&quot;,&quot;) alist ## [&#39;banana&#39;, &#39; apple&#39;, &#39; cherry&#39;] there are some whitespce in the splitted elements in the list alist[1].strip() ## &#39;apple&#39; 1.3.4.2 String Formatting: name = &quot;Alice&quot; age = 25 formatted_string = f&quot;My name is {name} and I am {age} years old.&quot; # Result: &#39;My name is Alice and I am 25 years old.&#39; 1.3.4.3 Escape Characters: escaped_string = &quot;This is a line.\\nThis is a new line.\\tThis is a tab.&quot; print(escaped_string) ## This is a line. ## This is a new line. This is a tab. 1.3.4.4 Raw Strings: raw_string = r&quot;This is a raw string \\n\\t No escape characters here.&quot; print(raw_string) ## This is a raw string \\n\\t No escape characters here. 1.3.4.5 Membership and Operations: # Checking membership contains_py = &#39;py&#39; in my_string # Result: True # String repetition repeated_string = my_string * 3 # Result: &#39;PythonPythonPython&#39; Strings in Python are immutable, meaning once a string is created, you cannot modify its contents. Any operation that appears to modify a string actually creates a new string. Understanding these operations and methods is crucial for working effectively with strings in Python. 1.3.4.6 loop thru strings my_txt = &quot;life&quot; for i in my_txt: print(i.upper()) ## L ## I ## F ## E 1.3.4.7 in/not in check if a phrase is present in a string my_txt = &quot;life is good!&quot; print(&quot;good&quot; in my_txt) ## True if &quot;good&quot; in my_txt: print(my_txt) ## life is good! if &quot;bad&quot; not in my_txt: print(&quot;&#39;bad&#39; is not in the text&quot;) ## &#39;bad&#39; is not in the text 1.4 Control Statements 1.4.1 Looping 1.4.2 Looping Extra for-else for i in range(5): break else: print(&#39;else runs cus break didnt run&#39;) In a for-else block, if break runs in the for loop, else doesn’t run if break doesn’t run in the for loop, else will run break vs continue break stops the entire loop immediately when L=‘C’, break happens, and the entire loop stops. LETTERS = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;] for L in LETTERS: if L == &#39;C&#39;: break print(L) ## A ## B continue skips to the next iteration, without stopping the entire loop LETTERS = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;] for L in LETTERS: if L == &#39;C&#39;: continue print(L) ## A ## B ## D ## E when L='C', continue executes, and the iteration for L='C' is skipped. Instead we skip over to the next iteration immediately, where L='D' Note that continue doesn’t stop the entire loop like break enumerate &amp; zip enumerate() allows us to generate both index and element at the same time when iterating through a list (or similar iterable). LETTERS = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;] for i,L in enumerate(LETTERS): print(i, L) ## 0 A ## 1 B ## 2 C ## 3 D ## 4 E zip() allows us to iterate through 2 or more lists (or iterables) at once. names = [&#39;Adam&#39;, &#39;Eve&#39;, &#39;Joe&#39;] ages = [25,35,18] for name, age in zip(names, ages): print(name, age) ## Adam 25 ## Eve 35 ## Joe 18 1.5 Functions In Python, return and print are used for different purposes in functions: return: return is used to send a value back to the caller of the function. When a function is called, it can perform some operations and then use return to send a result back to where the function was called. The value returned by return can be stored in a variable, used in expressions, or passed to other functions. Once return is executed, the function terminates immediately. Example: def get_greeting(): return &quot;Hello, World!&quot; greeting = get_greeting() print(greeting) # This will print: Hello, World! print: print is used to output text to the console. It does not send any value back to the caller; it simply outputs the given string or other data types to the standard output (usually the console). The function continues executing after print unless it encounters a return or another statement that terminates the function. Example: def display_greeting(): print(&quot;Hello, World!&quot;) display_greeting() # This will print: Hello, World! 1.5.1 Summary Use return to send a value from the function to its caller. Use print to display a value to the console. Here is a combined example to illustrate both: def get_and_display_greeting(): greeting = &quot;Hello, World!&quot; print(greeting) # This will print: Hello, World! return greeting returned_value = get_and_display_greeting() print(f&quot;The returned value is: {returned_value}&quot;) # This will print: The returned value is: Hello, World! In this example, print outputs the greeting to the console, and return sends the greeting back to where the function was called, which is then stored in returned_value and printed again. Note:Functions that do not have an explicit return expression will implicitly return the None object. The details of None will be covered in a later exercise. For the purposes of this exercise and explanation, None is a placeholder that represents nothing, or null: "],["pandas-library.html", "Chapter 2 Pandas Library 2.1 Data Frames 2.2 read data 2.3 Recoding Columns in a Pandas DataFrame", " Chapter 2 Pandas Library run pip3 install pandas or run !pip install pandas on rstudio terminal or mac terminal or jupyter notebook import pandas as pd pd.set_option(&#39;display.max_columns&#39;, None) 2.1 Data Frames 2.1.1 Data frame creation Sometimes you may need to create a data frame ## empty data frame df1 = pd.DataFrame(dtype = &#39;float64&#39;) ## name &#39;pd&#39; is not defined df1 ## name &#39;df1&#39; is not defined df2 = pd.DataFrame({&#39;A&#39; : []}) ## name &#39;pd&#39; is not defined df2 ## name &#39;df2&#39; is not defined Is df2 empty? There is column name but it is still empty. df2.empty ## name &#39;df2&#39; is not defined How to create a sample data frame? From a dictionary my_dict = {&#39;Col_1&#39;: [1,2,3,4], &#39;Col_2&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;], &#39;Col_3&#39;: 1984} my_df = pd.DataFrame(my_dict) ## name &#39;pd&#39; is not defined my_df[:5] ## name &#39;my_df&#39; is not defined a_list = [1,2,3,4] b_list = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] ## df3 = pd.DataFrame({&#39;var1&#39;: a_list, &#39;var2&#39;: b_list}) ## name &#39;pd&#39; is not defined df3 ## name &#39;df3&#39; is not defined 2.1.2 Read csv files df_csv = pd.read_csv(&#39;data/college.csv&#39;).iloc[:100, :5] ## name &#39;pd&#39; is not defined df_csv[:5] ## name &#39;df_csv&#39; is not defined 2.1.3 Data attributes 2.1.3.1 shape of data frame df_csv.shape ## name &#39;df_csv&#39; is not defined print(&quot;number of rows:&quot;, df_csv.shape[0], &quot;\\nnumber of columns:&quot;, df_csv.shape[1]) ## name &#39;df_csv&#39; is not defined 2.1.3.2 Columns How to get the column names? –&gt; Column names are stored in columns attribute. df_csv.columns ## name &#39;df_csv&#39; is not defined list(df_csv.columns) ## name &#39;df_csv&#39; is not defined df_csv.columns.to_list() ## name &#39;df_csv&#39; is not defined for cols in df_csv.columns: print(cols) ## name &#39;df_csv&#39; is not defined 2.1.3.3 data types in dataframe df_csv.dtypes ## name &#39;df_csv&#39; is not defined [types for types in df_csv.dtypes] ## name &#39;df_csv&#39; is not defined 2.1.3.4 index of the data frame df_csv[:5] ## name &#39;df_csv&#39; is not defined df_csv.index ## name &#39;df_csv&#39; is not defined for i in df_csv.index: if i &lt; 5: print(i) ## name &#39;df_csv&#39; is not defined 2.1.3.5 assign a new index df = df_csv.copy() ## name &#39;df_csv&#39; is not defined df.index = df.state ## name &#39;df&#39; is not defined df[:5] ## name &#39;df&#39; is not defined 2.1.3.6 index to column df = df_csv.copy() ## name &#39;df_csv&#39; is not defined df[&#39;index_column&#39;] = df.index ## name &#39;df&#39; is not defined df[:5] ## name &#39;df&#39; is not defined calling keys() function: output is similar to columns attributes df_csv.keys() ## name &#39;df_csv&#39; is not defined column.values method returns an array of index. list(df_csv.columns.values) ## name &#39;df_csv&#39; is not defined Using tolist() method with values with given the list of columns. list(df_csv.columns.values.tolist()) ## name &#39;df_csv&#39; is not defined Using sorted() method : sorted() method will return the list of columns sorted in alphabetical order. sorted(df3) ## name &#39;df3&#39; is not defined 2.1.4 Create or add a new column You can create a new column in a pandas DataFrame based on the values of existing columns using various methods, such as assignment, the apply() function, or vectorized operations. Here are some examples: 2.1.5 Explore Data #recipes.head() 2.1.6 query method The query method in Python, specifically in the pandas library, is a powerful tool for data scientists when it comes to filtering and selecting data from a DataFrame. Here’s an overview of the query method in the context of data science: Purpose of the query Method: Simplifies Data Filtering: The query method allows you to filter data using a string expression, which is often more intuitive and readable than traditional boolean indexing. Improves Readability: By using query, complex filtering conditions can be written in a way that resembles SQL, making the code easier to understand and maintain. Key Features and Advantages: Readability and Simplicity: The query method lets you filter DataFrames using natural language-like expressions. For example: df.query(&quot;column_name &gt; value&quot;) This is easier to read than: df[df[&#39;column_name&#39;] &gt; value] Support for Local Variables: You can reference local Python variables inside the query expression by prefixing them with @. This is useful when the filtering criteria are dynamic or based on external conditions. threshold = 90 df.query(&quot;grade &gt; @threshold&quot;) Chaining Queries: The query method can be chained to apply multiple filters sequentially, which can be more readable than combining multiple conditions using &amp; or |. df.query(&quot;grade &gt; 90&quot;).query(&quot;favorite_color == &#39;red&#39;&quot;) Avoiding Complex Boolean Indexing: In complex scenarios where multiple conditions need to be applied, boolean indexing can become cumbersome. The query method simplifies this by allowing conditions to be expressed in a single line. df.query(&quot;age &gt; 20 and score &lt; 80&quot;) 2.1.6.1 Considerations: Performance: While query is readable, it might be slightly slower than traditional indexing methods for very large DataFrames. However, the difference is often negligible in most data science applications. Syntax Limitations: The query method only supports a subset of Python syntax, so certain complex operations may still require traditional methods. 2.2 read data 2.2.1 csv file IBM sample data: I could not run with “https” because I did not have a certificate installed. So, I go on with “http” and it worked. data_link = &quot;http://s3-api.us-geo.objectstorage.softlayer.net/cf-courses-data/CognitiveClass/DS0103EN/labs/data/recipes.csv&quot; recipes = pd.read_csv(data_link) 2.2.2 xlsx file pandas.read_excel(io = path, sheet_name = 0, header = 0, names = None, index_col = None, usecols = None) This returns dataframe object. df = pd.read_excel(io = &quot;./data/segmentation.xlsx&quot;, sheet_name = &quot;sheet&quot;) ## name &#39;pd&#39; is not defined df.head(n=5) ## name &#39;df&#39; is not defined 2.2.3 rename/assign new column names Renaming or assigning new column names in pandas DataFrame is a common operation, and there are several ways to accomplish it. Here are some examples with explanations: 2.2.3.1 Using the rename() method: The rename() method allows you to rename columns by specifying a dictionary where keys are the current column names and values are the new column names. df = df_csv.copy() ## name &#39;df_csv&#39; is not defined df.rename(columns={&#39;id&#39;: &#39;NEW_ID&#39;}, inplace=True) ## name &#39;df&#39; is not defined df.columns.to_list() ## name &#39;df&#39; is not defined Setting inplace=True will modify the DataFrame in place, otherwise a new DataFrame with the renamed columns will be returned. 2.2.3.2 Direct assignment with dictionary: You can directly assign new column names to the columns attribute of the DataFrame using a dictionary. Note: you need to specify all the column names in the dictionary. df = df_csv[[&#39;name&#39;, &#39;state&#39;, &#39;id&#39;]].copy() ## name &#39;df_csv&#39; is not defined df.columns = {&#39;MY_NAME&#39;: &#39;name&#39;, &#39;MY_STATE&#39;: &#39;state&#39;, &#39;id&#39;:&#39;id&#39;} ## name &#39;df&#39; is not defined df.columns.to_list() ## name &#39;df&#39; is not defined 2.2.3.3 Using list assignment: You can directly assign a list of column names to the columns attribute of the DataFrame. Note: Make sure the length of the list matches the number of columns in the DataFrame. df = df_csv[[&#39;name&#39;, &#39;state&#39;]].copy() ## name &#39;df_csv&#39; is not defined df.columns = [&#39;MY_NAME&#39;, &#39;MY_STATE&#39;] ## name &#39;df&#39; is not defined df.columns.to_list() ## name &#39;df&#39; is not defined 2.2.3.4 Assigning new column names during DataFrame creation: You can provide the columns parameter when creating a DataFrame to specify the column names. df = pd.DataFrame(data, columns=[&#39;column1&#39;, &#39;column2&#39;, &#39;column3&#39;]) 2.2.3.5 to uppercase all column names df = df_csv.copy() ## name &#39;df_csv&#39; is not defined df.columns = [x.upper() for x in df.columns] ## name &#39;df&#39; is not defined df.columns.to_list() ## name &#39;df&#39; is not defined 2.2.3.6 rename Renaming column names is a standard procedure most of the time. We may need to standardize column names, mostly make them clean. There is a nice link here. Lets create a sample data frame df = pd.DataFrame({&#39;A?la&#39;: [1,2,3,4], &#39;PYTHON&#39;: [&#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;], &#39;col 3&#39;: [&#39;1&#39;,&#39;1&#39;,&#39;b&#39;,&#39;b&#39;]}) ## name &#39;pd&#39; is not defined df ## name &#39;df&#39; is not defined Method 1: Rename Specific Columns df.rename(columns = {&#39;PYTHON&#39;:&#39;Python&#39;}, inplace = False) ## name &#39;df&#39; is not defined ### list column names list(df) ## name &#39;df&#39; is not defined Method 2: Rename All Columns new_names = [&#39;new_name1&#39;, &#39;new_name2&#39;,&#39;new_name3&#39;] df.columns = new_names ## name &#39;df&#39; is not defined list(df) ## name &#39;df&#39; is not defined Method 3: Replace Specific Characters in Columns ### set problematic names problem_names = [&#39;VAR1$$$&#39;, &#39;var2&#39;,&#39;Var3###&#39;] df.columns = problem_names ## name &#39;df&#39; is not defined ### removing bad characters df.columns = df.columns.str.replace(&#39;$&#39;, &#39;&#39;, regex = True) ## name &#39;df&#39; is not defined df.columns = df.columns.str.replace(&#39;#&#39;, &#39;&#39;, regex = True) ## name &#39;df&#39; is not defined list(df) ## name &#39;df&#39; is not defined clean column names Generally we expect clean columns to be: 1. short 2. meaningful 3. no space 4. no special character 5. probably lowercase ### set problematic names problem_names = [&#39;VAR $1&#39;, &#39;var #2&#39;,&#39;Var ? 3 &#39;] df.columns = problem_names ## name &#39;df&#39; is not defined ## Column names: remove white spaces and convert to lower case df.columns= df.columns.str.strip() ## name &#39;df&#39; is not defined ## Column names: convert to lower case df.columns = df.columns.str.lower() ## name &#39;df&#39; is not defined ## Column names: convert to lower case df = df.rename(columns = str.lower) ## name &#39;df&#39; is not defined ## removing bad characters df.columns = df.columns.str.replace(&#39;$&#39;, &#39;&#39;, regex = True) ## name &#39;df&#39; is not defined df.columns = df.columns.str.replace(&#39;#&#39;, &#39;&#39;, regex = True) ## name &#39;df&#39; is not defined df.columns = df.columns.str.replace(&#39;?&#39;, &#39;&#39;, regex = True) ## name &#39;df&#39; is not defined df.columns = df.columns.str.replace(&#39; &#39;, &#39;&#39;, regex = True) ## name &#39;df&#39; is not defined list(df) ## name &#39;df&#39; is not defined sometimes we need them to be uppercase ## Column names: convert to upper case df.columns = df.columns.str.upper() ## name &#39;df&#39; is not defined list(df) ## name &#39;df&#39; is not defined 2.2.4 Subsetting 2.2.4.1 by columns selected_cols = [&#39;id&#39;, &#39;name&#39;, &#39;city&#39;] df_csv[selected_cols] ## name &#39;df_csv&#39; is not defined 2.2.4.2 Label based: df.loc[row_label, column_label] Selecting Rows and Columns by Labels: You can use df.loc[] to select rows and columns of a DataFrame using labels. The syntax is df.loc[row_label, column_label]. You can specify a single label or a list of labels for both rows and columns. row label is the index. # Select a single row and column df_csv.loc[1, &#39;name&#39;] ## name &#39;df_csv&#39; is not defined # Select multiple rows and columns df_csv.loc[[0, 2, 4], [&#39;name&#39;, &#39;state&#39;]] ## name &#39;df_csv&#39; is not defined # Select rows from &#39;row_label_start&#39; to &#39;row_label_end&#39; df_csv.loc[0:4] ## name &#39;df_csv&#39; is not defined ## all same # df_csv.loc[0:4, ] # df_csv.loc[0:4, :] # Select rows where a condition is True df_csv.loc[df_csv[&#39;id&#39;] &lt; 101000] ## name &#39;df_csv&#39; is not defined df = df_csv.copy() ## name &#39;df_csv&#39; is not defined # Set a value for a specific row and column df.loc[10, &#39;name&#39;] = &#39;My University&#39; ## name &#39;df&#39; is not defined 2.2.4.3 Filtering Rows Based on a Single Condition: df = df_csv.copy() ## name &#39;df_csv&#39; is not defined # Select rows where the &#39;column_name&#39; equals a specific value df[df[&#39;name&#39;] == &#39;Auburn University&#39;] ## name &#39;df&#39; is not defined df[df.name == &#39;Auburn University&#39;] ## name &#39;df&#39; is not defined 2.2.4.4 Filtering Rows Based on Multiple Conditions (AND): # Select rows where &#39;column1&#39; equals &#39;value1&#39; and &#39;column2&#39; equals &#39;value2&#39; df[(df.city == &#39;Birmingham&#39;) &amp; (df.state == &#39;AL&#39;)] ## name &#39;df&#39; is not defined 2.2.5 copy When you use loc/iloc to create a subset of the DataFrame, you are also creating a view into the original DataFrame. Modifications to the subset will reflect in the original DataFrame, and vice versa. subset = df.loc[&#39;row_label1&#39;:&#39;row_label5&#39;, &#39;column_labelA&#39;:&#39;column_labelB&#39;] subset = df.iloc[0:5, 1:3] # Select rows 0 to 4 and columns 1 to 2 To create an independent copy of the DataFrame, you can use the copy() method. This ensures that modifications to the copied DataFrame do not affect the original DataFrame. copy_df = df.copy() ## name &#39;df&#39; is not defined 2.3 Recoding Columns in a Pandas DataFrame Data manipulation is a crucial part of any data science project. One common task is recoding columns in a DataFrame, which involves transforming the values in a column based on certain rules or mapping schemes. This can be necessary for various reasons, such as preparing data for analysis, converting categorical variables, or cleaning data. In this section, we will explore different methods to recode columns in a Pandas DataFrame. 2.3.1 Using map and replace The map and replace methods are convenient for simple value transformations and mappings. Using map for Recoding: The map method is useful for replacing values in a Series (a single column in a DataFrame) according to a mapping dictionary. import pandas as pd # Sample DataFrame data = { &#39;Category&#39;: [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;] } df = pd.DataFrame(data) # Mapping dictionary category_map = { &#39;A&#39;: &#39;Alpha&#39;, &#39;B&#39;: &#39;Beta&#39;, &#39;C&#39;: &#39;Gamma&#39; } # Recoding using map df[&#39;Category_Recoded&#39;] = df[&#39;Category&#39;].map(category_map) print(df) Output: Category Category_Recoded 0 A Alpha 1 B Beta 2 C Gamma 3 A Alpha 4 B Beta 5 C Gamma In this example, we created a mapping dictionary category_map and used the map method to create a new column Category_Recoded with the recoded values. Using replace for Recoding: The replace method can be used for more flexible replacements, including partial string replacements and handling missing values. # Sample DataFrame with NaN values data = { &#39;Category&#39;: [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, None] } df = pd.DataFrame(data) # Recoding using replace df[&#39;Category_Recoded&#39;] = df[&#39;Category&#39;].replace({ &#39;A&#39;: &#39;Alpha&#39;, &#39;B&#39;: &#39;Beta&#39;, &#39;C&#39;: &#39;Gamma&#39;, None: &#39;Unknown&#39; }) print(df) Output: Category Category_Recoded 0 A Alpha 1 B Beta 2 C Gamma 3 A Alpha 4 B Beta 5 C Gamma 6 None Unknown In this example, we used the replace method to handle missing values (None) and recode the Category column. 2.3.1.1 2. Using apply for Custom Functions For more complex recoding logic, you can use the apply method with a custom function. # Sample DataFrame data = { &#39;Score&#39;: [85, 92, 78, 88, 95, 70] } df = pd.DataFrame(data) # Custom function to recode scores def recode_score(score): if score &gt;= 90: return &#39;A&#39; elif score &gt;= 80: return &#39;B&#39; elif score &gt;= 70: return &#39;C&#39; else: return &#39;D&#39; # Recoding using apply df[&#39;Grade&#39;] = df[&#39;Score&#39;].apply(recode_score) print(df) Output: Score Grade 0 85 B 1 92 A 2 78 C 3 88 B 4 95 A 5 70 C In this example, we defined a custom function recode_score that assigns letter grades based on numerical scores. We then used the apply method to apply this function to the Score column and create a new Grade column. 2.3.1.2 3. Using Conditional Logic with np.where The np.where function from the NumPy library allows for vectorized conditional operations, which can be very efficient for large DataFrames. import numpy as np # Sample DataFrame data = { &#39;Age&#39;: [15, 22, 45, 35, 63, 25] } df = pd.DataFrame(data) # Recoding using np.where df[&#39;Age_Group&#39;] = np.where(df[&#39;Age&#39;] &lt; 18, &#39;Child&#39;, np.where(df[&#39;Age&#39;] &lt; 65, &#39;Adult&#39;, &#39;Senior&#39;)) print(df) Output: Age Age_Group 0 15 Child 1 22 Adult 2 45 Adult 3 35 Adult 4 63 Adult 5 25 Adult In this example, we used np.where to classify individuals into age groups based on their age. The first condition checks if the age is less than 18, classifying the individual as a “Child”. If not, the second condition checks if the age is less than 65, classifying the individual as an “Adult”. Otherwise, the individual is classified as a “Senior”. 2.3.2 Summary Recoding columns in a Pandas DataFrame is a common task in data preparation and transformation. This section covered various methods for recoding: - Using the map method for straightforward value replacements. - Using the replace method for flexible value replacements. - Using the apply method with custom functions for complex recoding logic. - Using np.where for efficient conditional recoding. By mastering these techniques, you can effectively clean and transform your data to prepare it for analysis and modeling. Let’s explore what a.empty, a.bool(), a.item(), a.any(), and a.all() do in Python, particularly when used with pandas Series or DataFrames. 2.3.3 1. a.empty Purpose: Checks if a DataFrame or Series is empty. Usage: Returns True if the DataFrame or Series has no elements (i.e., zero rows or zero columns). Otherwise, it returns False. 2.3.3.1 Example: import pandas as pd # Empty DataFrame df_empty = pd.DataFrame() print(df_empty.empty) # Output: True # Non-empty DataFrame df_non_empty = pd.DataFrame({&#39;A&#39;: [1, 2]}) print(df_non_empty.empty) # Output: False # Empty Series s_empty = pd.Series([]) print(s_empty.empty) # Output: True # Non-empty Series s_non_empty = pd.Series([1, 2, 3]) print(s_non_empty.empty) # Output: False 2.3.4 2. a.bool() Purpose: Returns the boolean value of a Series or DataFrame. Usage: Can be used only if the Series or DataFrame contains exactly one element. If there is more than one element, it raises a ValueError. 2.3.4.1 Example: import pandas as pd # Single-element Series s = pd.Series([True]) print(s.bool()) # Output: True # Multi-element Series s_multi = pd.Series([True, False]) # print(s_multi.bool()) # Raises ValueError: The truth value of a Series is ambiguous. 2.3.5 3. a.item() Purpose: Returns the single item from a Series. Usage: Can be used only if the Series has exactly one element. Raises a ValueError if there are multiple elements. 2.3.5.1 Example: import pandas as pd # Single-element Series s_single = pd.Series([42]) print(s_single.item()) # Output: 42 # Multi-element Series s_multi = pd.Series([42, 43]) # print(s_multi.item()) # Raises ValueError: can only convert an array of size 1 to a Python scalar 2.3.6 4. a.any() Purpose: Checks if any element in a Series or DataFrame is True. Usage: Returns True if at least one element is True; otherwise, returns False. Can be applied to both Series and DataFrames. 2.3.6.1 Example: import pandas as pd # Example Series s = pd.Series([False, True, False]) print(s.any()) # Output: True # Example DataFrame df = pd.DataFrame({&#39;A&#39;: [0, 1, 0], &#39;B&#39;: [False, False, False]}) print(df.any()) # Output: # A True # B False # dtype: bool # To check if any value is True in the entire DataFrame print(df.any().any()) # Output: True 2.3.7 5. a.all() Purpose: Checks if all elements in a Series or DataFrame are True. Usage: Returns True if all elements are True; otherwise, returns False. Can be applied to both Series and DataFrames. 2.3.7.1 Example: import pandas as pd # Example Series s = pd.Series([True, True, True]) print(s.all()) # Output: True # Example DataFrame df = pd.DataFrame({&#39;A&#39;: [1, 1, 1], &#39;B&#39;: [True, True, True]}) print(df.all()) # Output: # A True # B True # dtype: bool # Checking if all values are True in the entire DataFrame print(df.all().all()) # Output: True 2.3.8 Summary: a.empty: Checks if the DataFrame or Series is empty. a.bool(): Converts a Series or DataFrame with one element to a boolean. a.item(): Retrieves a single element from a Series (if it has only one element). a.any(): Checks if any element is True. a.all(): Checks if all elements are True. These functions help in checking conditions or accessing data in pandas objects and are useful in various data analysis tasks. "],["random.html", "Chapter 3 RANDOM 3.1 Some Functions", " Chapter 3 RANDOM 3.1 Some Functions 3.1.1 input function Example: Multiplication Chart i = int(input(&quot;Enter a number = &quot;)) for x in range(i+1) : y = x*5 print(x,&quot;x&quot;,5,&quot;=&quot;,y) "],["numpy-module.html", "Chapter 4 Numpy Module 4.1 Numpy Library", " Chapter 4 Numpy Module In Python we have lists that serve the purpose of arrays, but they are slow to process. NumPy aims to provide an array object that is up to 50x faster than traditional Python lists. The array object in NumPy is called ndarray, it provides a lot of supporting functions that make working with ndarray very easy. Arrays are very frequently used in data science, where speed and resources are very important. 4.1 Numpy Library NumPy is a Python library used for working with arrays. It also has functions for working in domain of linear algebra, fourier transform, and matrices. NumPy stands for Numerical Python. A numpy array is similar to a list. It’s usually fixed in size and each element is of the same type. We can cast a list to a numpy array by first importing numpy: [ speed and memory advantages] the basics and array creation Indexing and slicing Basic Operations Universal Functions pip install numpy import before use import numpy as np print(np.__version__) ## 1.26.4 4.1.1 A. One dimensional array 4.1.1.1 the basics and array creation Create an array from a list object x = np.array([0, 1, 2, 3, 4]) type(x) ## &lt;class &#39;numpy.ndarray&#39;&gt; Create an array from a tuple object np.array( (1, 2, 3, 4) ) ## array([1, 2, 3, 4]) 4.1.1.2 Attributes of an array x = np.array( [1, 2, 3, 4] ) print(&quot;type of the object ---&gt;&quot;, type(x)) ## type of the object ---&gt; &lt;class &#39;numpy.ndarray&#39;&gt; print(&quot;type of values in object ---&gt;&quot;, x.dtype) ## type of values in object ---&gt; int64 print(&quot;size of the array ---&gt;&quot;, x.size) ## size of the array ---&gt; 4 print(&quot;dimension of the object ---&gt;&quot;, x.ndim ) ## dimension of the object ---&gt; 1 print(&quot;size and dimension ---&gt;&quot;, x.shape) ## size and dimension ---&gt; (4,) 4.1.1.3 Indexing and Slicing slicing: array[start:stop:step] arr = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) # Get elements from index 2 to 5 (exclusive) print(arr[2:5]) # Output: [2, 3, 4] ## [2 3 4] # Get every other element starting from index 1 print(arr[1::2]) # Output: [1, 3, 5, 7] ## [1 3 5 7 9] # Get all elements in reverse order print(arr[::-1]) # Output: [9, 8, 7, 6, 5, 4, 3, 2, 1, 0] ## [9 8 7 6 5 4 3 2 1 0] 4.1.1.4 Basic Vector Operations Addition: a + b or np.add(a, b) - Element-wise addition of two arrays. Subtraction: a - b or np.subtract(a, b) - Element-wise subtraction of two arrays. Multiplication: a * b or np.multiply(a, b) - Element-wise multiplication of two arrays. Division: a / b or np.divide(a, b) - Element-wise division of two arrays. Power: a ** b or np.power(a, b) - Element-wise exponentiation of two arrays. a = np.array([1, 2, 3]) b = np.array([4, 5, 6]) print(a + b) # Output: [5, 7, 9] ## [5 7 9] print(a - b) # Output: [-3, -3, -3] ## [-3 -3 -3] print(a * b) # Output: [ 4, 10, 18] ## [ 4 10 18] print(a / b) # Output: [0.25, 0.4, 0.5 ] ## [0.25 0.4 0.5 ] print(a ** b) # Output: [ 1, 32, 729] ## [ 1 32 729] print(np.add(a, b)) ## [5 7 9] print(np.subtract(a, b)) ## [-3 -3 -3] print(np.multiply(a, b)) ## [ 4 10 18] print(np.divide(a, b)) ## [0.25 0.4 0.5 ] print(np.power(a, b)) ## [ 1 32 729] 4.1.1.5 Other Vector Operations Sum: a.sum() or np.sum(a) - Calculate the sum of all elements in the array. Mean: a.mean() or np.mean(a) - Calculate the mean of all elements in the array. Median: np.median(a) - Calculate the median of all elements in the array. Standard Deviation: a.std() or np.std(a) - Calculate the standard deviation of all elements in the array. Dot Product: a.dot(b) - Calculate the dot product of two arrays. a = np.array([1, 2, 3, 4, 5]) print(np.sum(a)) # Output: 15 ## 15 print(np.mean(a)) # Output: 3.0 ## 3.0 print(np.median(a)) # Output: 3.0 ## 3.0 print(np.std(a)) # Output: 1.58113883046 ## 1.4142135623730951 a = np.array([1, 2, 3, 4, 5]) print(a.sum()) # Output: 15 ## 15 print(np.mean(a)) # Output: 3.0 ## 3.0 print(np.median(a)) # Output: 3.0 ## 3.0 print(a.std()) # Output: 1.58113883046 ## 1.4142135623730951 4.1.1.6 Matrix Multiplication Dot Product: a @ b or np.dot(a, b) - Matrix multiplication of two arrays. Matrix Product: a.dot(b) - Matrix multiplication of two arrays (alternative syntax). a = np.array([[1, 2], [3, 4]]) b = np.array([[5, 6], [7, 8]]) print(a @ b) # Output: [[19 22], [43 50]] ## [[19 22] ## [43 50]] print(np.dot(a, b)) # Output: [[19 22], [43 50]] ## [[19 22] ## [43 50]] print(a.dot(b)) # Output: [[19 22], [43 50]] ## [[19 22] ## [43 50]] "],["object-oriented-programming-for-data-scientists.html", "Chapter 5 Object-Oriented Programming for Data Scientists 5.1 Introduction to OOP 5.2 Classes and Objects 5.3 Attributes and Methods 5.4 Pandas Exercises", " Chapter 5 Object-Oriented Programming for Data Scientists 5.1 Introduction to OOP Object-Oriented Programming (OOP) is a programming paradigm centered around the concept of objects, which are instances of classes. OOP is particularly beneficial in data science because it allows for modular, reusable, and maintainable code. By encapsulating data and functions that operate on the data into objects, OOP helps in organizing complex data workflows and creating scalable data science solutions. Key Concepts of OOP: Class: A blueprint for creating objects. A class defines a set of attributes and methods that the created objects will have. Object: An instance of a class. Each object can have unique attribute values, even if they share the same class. Encapsulation: Bundling of data (attributes) and methods (functions) that operate on the data into a single unit (class). Inheritance: A mechanism where one class can inherit attributes and methods from another class. Polymorphism: The ability to use a single interface to represent different underlying data types. Abstraction: Hiding the complex implementation details and showing only the necessary features of an object. 5.1.1 What is Object-Oriented Programming? Object-Oriented Programming is a way of designing software by defining data structures as objects that can contain both data and functions. These objects interact with one another to perform tasks and solve problems. OOP concepts are particularly useful in data science for creating custom data structures, implementing machine learning models, and managing data pipelines. 5.1.2 Advantages of OOP Modularity: The source code for an object can be written and maintained independently of the source code for other objects. Reusability: Once an object is created, it can be reused in different programs. Scalability: OOP makes it easier to manage and scale large codebases. Maintainability: Code is easier to maintain and modify over time. 5.1.3 OOP vs. Procedural Programming Procedural programming focuses on functions, or procedures, that perform operations on data. In contrast, OOP focuses on objects that encapsulate data and the functions that operate on the data. Procedural Programming Example: # Procedural approach to calculating area of a rectangle def calculate_area(length, width): return length * width length = 5 width = 3 area = calculate_area(length, width) print(f&quot;The area of the rectangle is {area}&quot;) Object-Oriented Programming Example: # OOP approach to calculating area of a rectangle class Rectangle: def __init__(self, length, width): self.length = length self.width = width def calculate_area(self): return self.length * self.width rect = Rectangle(5, 3) area = rect.calculate_area() print(f&quot;The area of the rectangle is {area}&quot;) In the OOP example, the Rectangle class encapsulates both the data (length and width) and the behavior (calculate_area) in one place. This encapsulation makes the code more modular and easier to manage. 5.1.4 Practical Example in Data Science Let’s consider a practical example in data science where we create a class to represent a dataset and perform basic operations on it. import pandas as pd class DataSet: def __init__(self, data): self.data = pd.DataFrame(data) def get_summary(self): return self.data.describe() def add_column(self, column_name, data): self.data[column_name] = data def get_column(self, column_name): return self.data[column_name] # Creating a dataset instance data = { &#39;A&#39;: [1, 2, 3, 4, 5], &#39;B&#39;: [5, 4, 3, 2, 1] } dataset = DataSet(data) print(dataset.get_summary()) # Adding a new column dataset.add_column(&#39;C&#39;, [10, 20, 30, 40, 50]) print(dataset.get_column(&#39;C&#39;)) In this example, the DataSet class encapsulates the data in a Pandas DataFrame and provides methods to get a summary of the data, add a new column, and retrieve a specific column. This approach makes the code more organized and reusable, highlighting the advantages of OOP in data science. 5.2 Classes and Objects In Object-Oriented Programming (OOP), a class is a blueprint for creating objects (instances of the class). A class defines a set of attributes and methods that the created objects will have. Understanding classes and objects is fundamental to leveraging OOP in your data science projects. 5.2.1 Understanding Classes A class is a template for creating objects. It defines a set of attributes that will characterize any object created from the class and the methods that can be performed on these objects. Basic Structure of a Class: class MyClass: # Class attribute class_variable = &quot;I am a class variable&quot; # Constructor def __init__(self, instance_variable): self.instance_variable = instance_variable # Instance method def display(self): print(f&quot;Class Variable: {self.class_variable}&quot;) print(f&quot;Instance Variable: {self.instance_variable}&quot;) # Creating an instance of the class obj = MyClass(&quot;I am an instance variable&quot;) obj.display() In this example, MyClass has a class attribute class_variable, an instance attribute instance_variable, and an instance method display. 5.2.2 Creating Objects An object is an instance of a class. When a class is defined, no memory is allocated until an object of that class is created. Each object can have different attribute values, even if they share the same class. Creating and Using Objects: class DataPoint: def __init__(self, x, y): self.x = x self.y = y def display_point(self): print(f&quot;Point({self.x}, {self.y})&quot;) # Creating objects point1 = DataPoint(1, 2) point2 = DataPoint(3, 4) point1.display_point() # Output: Point(1, 2) point2.display_point() # Output: Point(3, 4) In this example, DataPoint is a class with attributes x and y and a method display_point. We create two instances of DataPoint, each with different values for x and y. 5.2.3 The self Parameter In Python, the self parameter is a reference to the current instance of the class. It is used to access variables that belong to the class. It must be the first parameter of any function in the class. Using self: class Employee: def __init__(self, name, salary): self.name = name self.salary = salary def display_employee(self): print(f&quot;Name: {self.name}, Salary: {self.salary}&quot;) # Creating an instance emp1 = Employee(&quot;John&quot;, 50000) emp1.display_employee() # Output: Name: John, Salary: 50000 Here, self.name and self.salary refer to the name and salary attributes of the instance emp1. 5.2.4 Real-world Examples in Data Science Let’s create a class to represent a simple linear regression model. Simple Linear Regression Class: import numpy as np class SimpleLinearRegression: def __init__(self): self.coefficient = None self.intercept = None def fit(self, X, y): X_mean = np.mean(X) y_mean = np.mean(y) self.coefficient = np.sum((X - X_mean) * (y - y_mean)) / np.sum((X - X_mean) ** 2) self.intercept = y_mean - self.coefficient * X_mean def predict(self, X): return self.coefficient * X + self.intercept # Sample data X = np.array([1, 2, 3, 4, 5]) y = np.array([2, 3, 5, 6, 5]) # Creating an instance and fitting the model model = SimpleLinearRegression() model.fit(X, y) # Making predictions predictions = model.predict(X) print(&quot;Predictions:&quot;, predictions) In this example: The SimpleLinearRegression class encapsulates the linear regression logic. The fit method calculates the coefficient and intercept based on the input data. The predict method uses the fitted model to make predictions on new data. This approach makes the linear regression model reusable and easy to integrate into larger data science workflows. 5.3 Attributes and Methods In Object-Oriented Programming (OOP), attributes and methods are key components of classes. Attributes are variables that hold data, while methods are functions that operate on this data. Understanding how to define and use attributes and methods is crucial for building effective data science applications using OOP. 5.3.1 Instance Attributes Instance attributes are variables that hold data specific to an instance of a class. They are defined within the __init__ method and are prefixed with self to indicate that they belong to the instance. Defining and Using Instance Attributes: class Student: def __init__(self, name, grade): self.name = name self.grade = grade def display_student(self): print(f&quot;Name: {self.name}, Grade: {self.grade}&quot;) # Creating instances student1 = Student(&quot;Alice&quot;, &quot;A&quot;) student2 = Student(&quot;Bob&quot;, &quot;B&quot;) student1.display_student() # Output: Name: Alice, Grade: A student2.display_student() # Output: Name: Bob, Grade: B In this example, name and grade are instance attributes that store data specific to each Student instance. 5.3.1.1 Class Attributes Class attributes are variables that are shared across all instances of a class. They are defined directly within the class body, outside any methods. Defining and Using Class Attributes: class School: school_name = &quot;Greenwood High&quot; # Class attribute def __init__(self, student_name): self.student_name = student_name # Instance attribute def display_student(self): print(f&quot;Student: {self.student_name}, School: {School.school_name}&quot;) # Creating instances student1 = School(&quot;Alice&quot;) student2 = School(&quot;Bob&quot;) student1.display_student() # Output: Student: Alice, School: Greenwood High student2.display_student() # Output: Student: Bob, School: Greenwood High In this example, school_name is a class attribute shared by all instances of the School class, while student_name is an instance attribute unique to each instance. 5.3.1.2 Instance Methods Instance methods are functions defined within a class that operate on instance attributes. They must include self as their first parameter to access instance attributes and other methods. Defining and Using Instance Methods: class Rectangle: def __init__(self, length, width): self.length = length self.width = width def calculate_area(self): return self.length * self.width def display_area(self): print(f&quot;Area: {self.calculate_area()}&quot;) # Creating an instance rect = Rectangle(5, 3) rect.display_area() # Output: Area: 15 In this example, calculate_area and display_area are instance methods that operate on the length and width attributes of the Rectangle instance. 5.3.1.3 Class Methods and Static Methods Class methods and static methods are two special types of methods in Python classes. Class methods operate on class attributes, while static methods are utility methods that do not operate on instance or class attributes. Class Methods: Class methods are defined using the @classmethod decorator and take cls (the class itself) as the first parameter. class Circle: pi = 3.14159 # Class attribute def __init__(self, radius): self.radius = radius @classmethod def from_diameter(cls, diameter): radius = diameter / 2 return cls(radius) def calculate_area(self): return Circle.pi * (self.radius ** 2) # Creating an instance using the class method circle = Circle.from_diameter(10) print(f&quot;Radius: {circle.radius}, Area: {circle.calculate_area()}&quot;) # Output: Radius: 5.0, Area: 78.53975 Static Methods: Static methods are defined using the @staticmethod decorator and do not take self or cls as a parameter. class MathUtils: @staticmethod def add(a, b): return a + b # Using the static method result = MathUtils.add(5, 3) print(f&quot;Result: {result}&quot;) # Output: Result: 8 In this example, add is a static method that performs addition without accessing any class or instance attributes. 5.3.2 Practical Examples with Data Science Models Let’s create a class to represent a simple linear regression model with attributes and methods tailored to data science. Linear Regression Class with Attributes and Methods: import numpy as np class SimpleLinearRegression: def __init__(self): self.coefficient = None self.intercept = None def fit(self, X, y): X_mean = np.mean(X) y_mean = np.mean(y) self.coefficient = np.sum((X - X_mean) * (y - y_mean)) / np.sum((X - X_mean) ** 2) self.intercept = y_mean - self.coefficient * X_mean def predict(self, X): return self.coefficient * X + self.intercept def score(self, X, y): y_pred = self.predict(X) ss_total = np.sum((y - np.mean(y)) ** 2) ss_residual = np.sum((y - y_pred) ** 2) r2_score = 1 - (ss_residual / ss_total) return r2_score # Sample data X = np.array([1, 2, 3, 4, 5]) y = np.array([2, 3, 5, 6, 5]) # Creating an instance and fitting the model model = SimpleLinearRegression() model.fit(X, y) # Making predictions predictions = model.predict(X) print(&quot;Predictions:&quot;, predictions) # Calculating R-squared score r2 = model.score(X, y) print(&quot;R-squared score:&quot;, r2) In this example: - The SimpleLinearRegression class encapsulates the logic for fitting a linear regression model, making predictions, and calculating the R-squared score. - The fit method calculates the coefficient and intercept. - The predict method uses the fitted model to make predictions on new data. - The score method calculates the R-squared score to evaluate the model’s performance. This approach demonstrates the power of using attributes and methods in a class to organize and encapsulate the functionality of a data science model. Encapsulation Public vs. Private Attributes Getter and Setter Methods Property Decorators Data Encapsulation in Data Science Projects Inheritance What is Inheritance? Single Inheritance Multiple Inheritance Overriding Methods The super() Function Reusing Code in Data Science Workflows Polymorphism Method Overloading Method Overriding Duck Typing Polymorphism in Data Processing Pipelines Abstraction Abstract Classes and Methods The abc Module Abstracting Common Data Science Tasks Special Methods The __init__ Method Other Magic Methods (__str__, __repr__, __len__, etc.) Operator Overloading Enhancing Data Science Classes with Special Methods Design Patterns in OOP Introduction to Design Patterns Common Design Patterns (Singleton, Factory, Observer, etc.) Design Patterns for Data Science Projects OOP with Data Science Libraries Integrating OOP with Libraries like Pandas, NumPy, and Scikit-learn Building Custom Transformers and Pipelines Extending Existing Classes Best Practices in OOP Writing Readable and Maintainable Code Principles of OOP (SOLID) Avoiding Common Pitfalls Best Practices in Data Science Context Case Study: Building a Data Science Application Problem Statement Designing the Class Structure Implementing the Solution Testing and Debugging Deploying Data Science Models Using OOP Advanced Topics Metaclasses Decorators and Descriptors MRO (Method Resolution Order) Advanced OOP Techniques in Data Science Summary and Key Takeaways Recap of Key Concepts Tips for Mastering OOP in Data Science Exercises and Projects Practice Problems Mini Projects Solutions 5.3.3 Dynamic Variables Dynamic variables are typically instance variables in the context of classes. They are created and managed at runtime, usually within the methods of a class. Each instance (or object) of a class can have different values for these variables. 5.3.3.1 Characteristics of Dynamic Variables: Instance-specific: Each instance of a class can have its own unique values for these variables. Defined within methods: Typically created and accessed using the self keyword within instance methods. Dynamic in nature: Can be added, modified, or deleted at runtime. Example: class DynamicExample: def __init__(self, value): self.dynamic_variable = value def update_value(self, new_value): self.dynamic_variable = new_value # Creating instances obj1 = DynamicExample(10) obj2 = DynamicExample(20) print(obj1.dynamic_variable) # Output: 10 print(obj2.dynamic_variable) # Output: 20 # Updating dynamic variable obj1.update_value(30) print(obj1.dynamic_variable) # Output: 30 5.3.4 Static Variables Static variables, also known as class variables, are shared across all instances of a class. They are defined at the class level and are not tied to any specific instance. These variables are accessed using the class name or any instance. 5.3.4.1 Characteristics of Static Variables: Class-wide: Shared among all instances of the class. Defined within the class but outside any methods: Typically declared directly within the class body. Consistent across instances: Changing the value affects all instances. Example: class StaticExample: static_variable = 42 # This is a static variable def __init__(self, value): self.instance_variable = value # This is a dynamic variable # Creating instances obj1 = StaticExample(10) obj2 = StaticExample(20) print(obj1.static_variable) # Output: 42 print(obj2.static_variable) # Output: 42 # Updating static variable through class StaticExample.static_variable = 100 print(obj1.static_variable) # Output: 100 print(obj2.static_variable) # Output: 100 # Accessing static variable through an instance obj1.static_variable = 200 print(obj1.static_variable) # Output: 200 print(obj2.static_variable) # Output: 100 # The class variable itself remains unchanged unless accessed through the class print(StaticExample.static_variable) # Output: 100 In this example: - static_variable is a class variable (static), shared across all instances. - instance_variable is an instance variable (dynamic), unique to each instance. 5.3.5 Summary Dynamic Variables: Instance-specific, created within methods, and can vary between instances. Static Variables: Shared across all instances, defined at the class level, and maintain consistent values unless explicitly changed. 5.4 Pandas Exercises import pandas as pd import numpy as np Question 1 Write a Pandas program to create and display a one-dimensional array-like object containing an array of data using Pandas module. Click me to see the sample solution Write a Pandas program to convert a Panda module Series to Python list and it’s type. Click me to see the sample solution Write a Pandas program to add, subtract, multiple and divide two Pandas Series. Sample Series: [2, 4, 6, 8, 10], [1, 3, 5, 7, 9] Click me to see the sample solution Write a Pandas program to compare the elements of the two Pandas Series. Sample Series: [2, 4, 6, 8, 10], [1, 3, 5, 7, 10] Click me to see the sample solution Write a Pandas program to convert a dictionary to a Pandas series. 5.4.1 sorting sort_values is a method in the pandas library used to sort the values in a DataFrame or Series. Purpose: sort_values is used to sort a DataFrame or Series by one or more columns or by the values in the Series. Syntax: DataFrame.sort_values(by, axis=0, ascending=True, inplace=False, kind=&#39;quicksort&#39;, na_position=&#39;last&#39;, ignore_index=False, key=None) 5.4.1.1 Examples: Sample dataframe import pandas as pd data = { &#39;NAME&#39;: [&#39;David&#39;, &#39;Alice&#39;, &#39;Charlie&#39;, &#39;Bob&#39;,], &#39;AGE&#39;: [25, 30, 40, 35], &#39;SALARY&#39;: [50000, 600000, 55000, 700000] } df = pd.DataFrame(data) df ## NAME AGE SALARY ## 0 David 25 50000 ## 1 Alice 30 600000 ## 2 Charlie 40 55000 ## 3 Bob 35 700000 Sort by a Single Column: # Sort by &#39;age&#39; in ascending order (DEFAULT) sorted_df = df.sort_values(by=&#39;NAME&#39;) print(sorted_df) ## NAME AGE SALARY ## 1 Alice 30 600000 ## 3 Bob 35 700000 ## 2 Charlie 40 55000 ## 0 David 25 50000 Sort by Multiple Columns: # Sort by &#39;age&#39; in ascending order, then by &#39;salary&#39; in descending order sorted_df = df.sort_values(by=[&#39;AGE&#39;, &#39;SALARY&#39;], ascending=[True, False]) print(sorted_df) ## unexpected indent (&lt;string&gt;, line 3) Handling NaN Values: data = { &#39;NAME&#39;: [&#39;Alice&#39;, &#39;Bob&#39;, &#39;Charlie&#39;, &#39;David&#39;], &#39;AGE&#39;: [25, 30, None, 40] } df = pd.DataFrame(data) # Sort by &#39;age&#39; and place NaN values at the start sorted_df = df.sort_values(by=&#39;AGE&#39;, na_position=&#39;first&#39;) print(sorted_df) ## NAME AGE ## 2 Charlie NaN ## 0 Alice 25.0 ## 1 Bob 30.0 ## 3 David 40.0 5.4.1.2 Key Points: axis: Axis to be sorted along (0 for index, 1 for columns). Default is 0. ignore_index: If True, the resulting index will be labeled 0, 1, 2, …, n - 1. Default is False. inplace: If True, perform the operation in place and return None. Default is False. 5.4.2 groupby operation The groupby operation in pandas is a powerful tool for aggregating and transforming data. It allows you to split your DataFrame into groups based on one or more columns, apply functions to each group, and then combine the results back into a DataFrame or Series. import pandas as pd data = { &#39;department&#39;: [&#39;Sales&#39;, &#39;Sales&#39;, &#39;HR&#39;, &#39;HR&#39;, &#39;IT&#39;, &#39;IT&#39;, &#39;Finance&#39;, &#39;Finance&#39;], &#39;employee&#39;: [&#39;Alice&#39;, &#39;Bob&#39;, &#39;Charlie&#39;, &#39;David&#39;, &#39;Eve&#39;, &#39;Frank&#39;, &#39;Grace&#39;, &#39;Hannah&#39;], &#39;salary&#39;: [70000, 80000, 50000, 60000, 90000, 85000, 75000, 65000], &#39;bonus&#39;: [5000, 7000, 4000, 6000, 9000, 8500, 7500, 6500] } df_company = pd.DataFrame(data) df_company ## department employee salary bonus ## 0 Sales Alice 70000 5000 ## 1 Sales Bob 80000 7000 ## 2 HR Charlie 50000 4000 ## 3 HR David 60000 6000 ## 4 IT Eve 90000 9000 ## 5 IT Frank 85000 8500 ## 6 Finance Grace 75000 7500 ## 7 Finance Hannah 65000 6500 5.4.2.1 Group by a Single Column Suppose you want to find the average salary by department. Final object is a series with index is department. # Group by &#39;department&#39; and calculate the mean salary grouped_df = df_company.groupby(&#39;department&#39;)[&#39;salary&#39;].mean() print(grouped_df) ## department ## Finance 70000.0 ## HR 55000.0 ## IT 87500.0 ## Sales 75000.0 ## Name: salary, dtype: float64 print(type(grouped_df)) ## &lt;class &#39;pandas.core.series.Series&#39;&gt; # Convert the resulting Series into a DataFrame grouped_df = grouped_df.reset_index() # Rename the column for clarity grouped_df.columns = [&#39;department&#39;, &#39;average_salary&#39;] grouped_df ## department average_salary ## 0 Finance 70000.0 ## 1 HR 55000.0 ## 2 IT 87500.0 ## 3 Sales 75000.0 5.4.2.2 Group by Multiple Columns: You can group by multiple columns. For example, find the total compensation (salary + bonus) for each employee in each department. # Group by &#39;department&#39; and &#39;employee&#39;, and calculate total compensation df_company[&#39;total_compensation&#39;] = df_company[&#39;salary&#39;] + df_company[&#39;bonus&#39;] grouped_df = df_company.groupby([&#39;department&#39;, &#39;employee&#39;])[&#39;total_compensation&#39;].sum() print(grouped_df) ## department employee ## Finance Grace 82500 ## Hannah 71500 ## HR Charlie 54000 ## David 66000 ## IT Eve 99000 ## Frank 93500 ## Sales Alice 75000 ## Bob 87000 ## Name: total_compensation, dtype: int64 print(type(grouped_df)) ## &lt;class &#39;pandas.core.series.Series&#39;&gt; 5.4.2.3 Aggregation Functions: You can use multiple aggregation functions on the grouped data. For example, find the sum and mean of the salary and bonus for each department. # Group by &#39;department&#39; and calculate sum and mean of &#39;salary&#39; and &#39;bonus&#39; agg_df = df_company.groupby(&#39;department&#39;).agg({ &#39;salary&#39;: [&#39;sum&#39;, &#39;mean&#39;], &#39;bonus&#39;: [&#39;sum&#39;, &#39;mean&#39;] }) print(agg_df) ## salary bonus ## sum mean sum mean ## department ## Finance 140000 70000.0 14000 7000.0 ## HR 110000 55000.0 10000 5000.0 ## IT 175000 87500.0 17500 8750.0 ## Sales 150000 75000.0 12000 6000.0 print(type(agg_df)) ## &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; 5.4.2.4 groupby and unnested data agg_df = df_company.groupby(&#39;department&#39;).agg( total_salary = pd.NamedAgg(column=&#39;salary&#39;, aggfunc=&#39;sum&#39;), avg_salary = pd.NamedAgg(column=&#39;salary&#39;, aggfunc=&#39;mean&#39;), total_bonus = pd.NamedAgg(column=&#39;bonus&#39;, aggfunc=&#39;sum&#39;), avg_bonus = pd.NamedAgg(column=&#39;bonus&#39;, aggfunc=&#39;mean&#39;) ) print(agg_df) ## total_salary avg_salary total_bonus avg_bonus ## department ## Finance 140000 70000.0 14000 7000.0 ## HR 110000 55000.0 10000 5000.0 ## IT 175000 87500.0 17500 8750.0 ## Sales 150000 75000.0 12000 6000.0 agg_df = df_company.groupby(&#39;department&#39;).agg({ &#39;salary&#39;: &#39;sum&#39;, &#39;bonus&#39;: &#39;sum&#39; }).rename(columns={ &#39;salary&#39;: &#39;total_salary&#39;, &#39;bonus&#39;: &#39;total_bonus&#39; }) agg_df[&#39;avg_salary&#39;] = df_company.groupby(&#39;department&#39;)[&#39;salary&#39;].mean() agg_df[&#39;avg_bonus&#39;] = df_company.groupby(&#39;department&#39;)[&#39;bonus&#39;].mean() print(agg_df) ## total_salary total_bonus avg_salary avg_bonus ## department ## Finance 140000 14000 70000.0 7000.0 ## HR 110000 10000 55000.0 5000.0 ## IT 175000 17500 87500.0 8750.0 ## Sales 150000 12000 75000.0 6000.0 5.4.2.5 Transformation data = { &#39;department&#39;: [&#39;Sales&#39;, &#39;Sales&#39;, &#39;HR&#39;, &#39;HR&#39;, &#39;IT&#39;, &#39;IT&#39;, &#39;Finance&#39;, &#39;Finance&#39;], &#39;employee&#39;: [&#39;Alice&#39;, &#39;Bob&#39;, &#39;Charlie&#39;, &#39;David&#39;, &#39;Eve&#39;, &#39;Frank&#39;, &#39;Grace&#39;, &#39;Hannah&#39;], &#39;salary&#39;: [70000, 80000, 50000, 60000, 90000, 85000, 95000, 65000], } df = pd.DataFrame(data) # Group by &#39;department&#39; and calculate sum of &#39;salary&#39; with transform df[&#39;total_salary&#39;] = df.groupby(&#39;department&#39;)[&#39;salary&#39;].transform(&#39;sum&#39;) print(df) ## department employee salary total_salary ## 0 Sales Alice 70000 150000 ## 1 Sales Bob 80000 150000 ## 2 HR Charlie 50000 110000 ## 3 HR David 60000 110000 ## 4 IT Eve 90000 175000 ## 5 IT Frank 85000 175000 ## 6 Finance Grace 95000 160000 ## 7 Finance Hannah 65000 160000 df[df[&#39;salary&#39;]&gt;80000] ## department employee salary total_salary ## 4 IT Eve 90000 175000 ## 5 IT Frank 85000 175000 ## 6 Finance Grace 95000 160000 5.4.2.6 Example Lets perform a standardization operation on the salary column within each group defined by the department column # Group by &#39;department&#39; and calculate sum of &#39;salary&#39; with transform df2 = df.copy() df2[&#39;demeaned_salary&#39;] = df2.groupby(&#39;department&#39;)[&#39;salary&#39;].transform(lambda x: (x - x.mean())) print(df2) ## department employee salary total_salary demeaned_salary ## 0 Sales Alice 70000 150000 -5000.0 ## 1 Sales Bob 80000 150000 5000.0 ## 2 HR Charlie 50000 110000 -5000.0 ## 3 HR David 60000 110000 5000.0 ## 4 IT Eve 90000 175000 2500.0 ## 5 IT Frank 85000 175000 -2500.0 ## 6 Finance Grace 95000 160000 15000.0 ## 7 Finance Hannah 65000 160000 -15000.0 5.4.2.7 Filtering Groups: You can filter out groups that meet a specific condition. For example, keep only departments with a total salary of more than $150,000. # Group by &#39;department&#39; and filter departments with total salary &gt; 150,000 filtered_df = df.groupby(&#39;department&#39;).filter(lambda x: x[&#39;salary&#39;].sum() &gt; 150000) print(filtered_df) ## department employee salary total_salary ## 4 IT Eve 90000 175000 ## 5 IT Frank 85000 175000 ## 6 Finance Grace 95000 160000 ## 7 Finance Hannah 65000 160000 df2[&#39;total_salary&#39;] = df.groupby(&#39;department&#39;)[&#39;salary&#39;].transform(&#39;sum&#39;) df2 = df2[df2[&#39;total_salary&#39;] &gt; 150000] df2 ## department employee salary total_salary demeaned_salary ## 4 IT Eve 90000 175000 2500.0 ## 5 IT Frank 85000 175000 -2500.0 ## 6 Finance Grace 95000 160000 15000.0 ## 7 Finance Hannah 65000 160000 -15000.0 5.4.2.8 Examples df2 = df.copy() df2 = df2.groupby(&#39;department&#39;).agg({&#39;salary&#39;: [&#39;sum&#39;, &#39;mean&#39;, &#39;count&#39;, &#39;min&#39;, &#39;max&#39;]}) df2 ## salary ## sum mean count min max ## department ## Finance 160000 80000.0 2 65000 95000 ## HR 110000 55000.0 2 50000 60000 ## IT 175000 87500.0 2 85000 90000 ## Sales 150000 75000.0 2 70000 80000 ` 5.4.3 Sample Solutions these are from interviewquery 5.4.3.1 Question import pandas as pd name_list = [&quot;Tim Voss&quot;, &quot;Nicole Johnson&quot;, &quot;Elsa Williams&quot;, &quot;John James&quot;, &quot;Catherine Jones&quot;] age_list = [19, 20, 21, 20, 23] color_list = [&quot;red&quot;, &quot;yellow&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;green&quot;] grades = [91, 95, 82, 75, 93] students = {&quot;name&quot; : name_list, &quot;age&quot; : age_list, &quot;favorite_color&quot; : color_list, &quot;grade&quot; : grades} students_df = pd.DataFrame(students) students_df ## name age favorite_color grade ## 0 Tim Voss 19 red 91 ## 1 Nicole Johnson 20 yellow 95 ## 2 Elsa Williams 21 green 82 ## 3 John James 20 blue 75 ## 4 Catherine Jones 23 green 93 Write a function named grades_colors to select only the rows where the student’s favorite color is green or red and their grade is above 90. def grades_colors(df): df = df[(df[&#39;favorite_color&#39;].isin([&#39;green&#39;, &#39;red&#39;])) &amp; (df[&#39;grade&#39;] &gt; 90)] return df grades_colors(students_df) ## name age favorite_color grade ## 0 Tim Voss 19 red 91 ## 4 Catherine Jones 23 green 93 Alternative students_df.query(&quot;favorite_color.isin((&#39;green&#39;, &#39;red&#39;)) and grade &gt; 90&quot;) ## name age favorite_color grade ## 0 Tim Voss 19 red 91 ## 4 Catherine Jones 23 green 93 Using query method colors = [&quot;green&quot;, &quot;red&quot;] students_df.query(&quot;favorite_color in @colors&quot;).query(&quot;grade &gt; 90&quot;) ## name age favorite_color grade ## 0 Tim Voss 19 red 91 ## 4 Catherine Jones 23 green 93 Using loc students_df.loc[(students_df[&#39;favorite_color&#39;].isin([&#39;green&#39;, &#39;red&#39;])) &amp; (students_df[&#39;grade&#39;] &gt; 90) ] ## name age favorite_color grade ## 0 Tim Voss 19 red 91 ## 4 Catherine Jones 23 green 93 Alternative color = students_df[&#39;favorite_color&#39;].isin([&#39;green&#39;, &#39;red&#39;]) grade = students_df[&#39;grade&#39;] &gt; 90 students_df.loc[(grade) &amp; (color)] 5.4.3.2 Question You are given a dataframe with a single column, ‘var’. Calculated the t-value for the mean of ‘var’ against a null hypothesis that \\(\\mu = \\mu_0\\) Note: You do not have to calculate the p-value of the test or run the test. var_data = [2,3,4,5,6,7,8,8,10] df = pd.DataFrame({&quot;var&quot;: var_data}) mu_0 = 5 def t_score(mu_0, df): n = df[&#39;var&#39;].count() sample_mean = df[&#39;var&#39;].mean() sample_std = df[&#39;var&#39;].std() t = (sample_mean - mu_0) / (sample_std / pow(n, 1/2)) return t t_score(mu_0, df) ## 1.018055620761245 5.4.4 Question Given a dataframe with three columns: client_id, ranking, value Write a function to fill the NaN values in the value column with the previous non-NaN value from the same client_id ranked in ascending order. If there doesn’t exist a previous client_id then return the previous value. client_id = [1001, 1001, 1001, 1002, 1002, 1002, 1003, 1003] ranking = [1, 2, 3, 1, 2, 3, 1, 2] value = [1000, pd.NA, 1200, 1500, 1250, pd.NA, 1100, pd.NA] clients_df = pd.DataFrame({ &#39;client_id&#39;: client_id, &#39;ranking&#39;: ranking, &#39;value&#39;: value }) def previous_nan_values(clients_df): clients_df = clients_df.sort_values(by=[&#39;client_id&#39;, &#39;ranking&#39;]) clients_df[&#39;value2&#39;] = clients_df.groupby(&#39;client_id&#39;)[&#39;value&#39;].ffill() return clients_df previous_nan_values(clients_df) ## client_id ranking value value2 ## 0 1001 1 1000 1000 ## 1 1001 2 &lt;NA&gt; 1000 ## 2 1001 3 1200 1200 ## 3 1002 1 1500 1500 ## 4 1002 2 1250 1250 ## 5 1002 3 &lt;NA&gt; 1250 ## 6 1003 1 1100 1100 ## 7 1003 2 &lt;NA&gt; 1100 5.4.5 Data Filtering and Selection: sample data data = { &#39;department&#39;: [&#39;Sales&#39;, &#39;Sales&#39;, &#39;HR&#39;, &#39;HR&#39;, &#39;IT&#39;, &#39;IT&#39;, &#39;Finance&#39;, &#39;Finance&#39;], &#39;employee&#39;: [&#39;Alice&#39;, &#39;Bob&#39;, &#39;Charlie&#39;, &#39;David&#39;, &#39;Eve&#39;, &#39;Frank&#39;, &#39;Grace&#39;, &#39;Hannah&#39;], &#39;salary&#39;: [70000, 80000, 50000, 60000, 90000, 85000, 95000, 65000], } df = pd.DataFrame(data) df ## department employee salary ## 0 Sales Alice 70000 ## 1 Sales Bob 80000 ## 2 HR Charlie 50000 ## 3 HR David 60000 ## 4 IT Eve 90000 ## 5 IT Frank 85000 ## 6 Finance Grace 95000 ## 7 Finance Hannah 65000 5.4.5.1 filtering rows df[df[&#39;employee&#39;] == &#39;Eve&#39;] ## department employee salary ## 4 IT Eve 90000 df[df[&#39;department&#39;].isin([&#39;HR&#39;, &#39;IT&#39;])] ## department employee salary ## 2 HR Charlie 50000 ## 3 HR David 60000 ## 4 IT Eve 90000 ## 5 IT Frank 85000 df[df[&#39;salary&#39;] &gt; 80000] ## department employee salary ## 4 IT Eve 90000 ## 5 IT Frank 85000 ## 6 Finance Grace 95000 df[(df[&#39;salary&#39;] &gt; 70000) &amp; (df[&#39;salary&#39;] &lt; 90000)] ## department employee salary ## 1 Sales Bob 80000 ## 5 IT Frank 85000 df.groupby(&#39;department&#39;).filter(lambda x: x[&#39;salary&#39;].sum() &gt; 150000) ## department employee salary ## 4 IT Eve 90000 ## 5 IT Frank 85000 ## 6 Finance Grace 95000 ## 7 Finance Hannah 65000 df.loc[0:3, :] ## department employee salary ## 0 Sales Alice 70000 ## 1 Sales Bob 80000 ## 2 HR Charlie 50000 ## 3 HR David 60000 df.iloc[0:3, :] ## department employee salary ## 0 Sales Alice 70000 ## 1 Sales Bob 80000 ## 2 HR Charlie 50000 5.4.5.2 filtering columns cols = [&#39;employee&#39;, &#39;salary&#39;] df[cols] ## employee salary ## 0 Alice 70000 ## 1 Bob 80000 ## 2 Charlie 50000 ## 3 David 60000 ## 4 Eve 90000 ## 5 Frank 85000 ## 6 Grace 95000 ## 7 Hannah 65000 df.loc[0:3, [&#39;employee&#39;, &#39;salary&#39;]] ## employee salary ## 0 Alice 70000 ## 1 Bob 80000 ## 2 Charlie 50000 ## 3 David 60000 df.iloc[0:3, :] ## department employee salary ## 0 Sales Alice 70000 ## 1 Sales Bob 80000 ## 2 HR Charlie 50000 5.4.6 Aggregation and Grouping: df.groupby(&#39;department&#39;)[&#39;salary&#39;].mean() ## department ## Finance 80000.0 ## HR 55000.0 ## IT 87500.0 ## Sales 75000.0 ## Name: salary, dtype: float64 5.4.7 Joining and Merging Data: merged_df = pd.merge(df1, df2, on=&#39;key&#39;) 5.4.8 recoding Sample Data data = { &#39;employee&#39;: [&#39;Alice&#39;, &#39;Bob&#39;, &#39;Charlie&#39;, &#39;David&#39;, &#39;Eve&#39;, &#39;Frank&#39;, &#39;Grace&#39;, &#39;Hannah&#39;], &#39;salary&#39;: [70000, 80000, 50000, 60000, 90000, 85000, 75000, 65000] } df = pd.DataFrame(data) df.head() ## employee salary ## 0 Alice 70000 ## 1 Bob 80000 ## 2 Charlie 50000 ## 3 David 60000 ## 4 Eve 90000 5.4.8.1 np.where() method # this condition creates a series of boolean condition = df[&#39;salary&#39;] &gt; 85000 df[&#39;label&#39;] = np.where(condition, &#39;high&#39;, &#39;low&#39;) df.head() ## employee salary label ## 0 Alice 70000 low ## 1 Bob 80000 low ## 2 Charlie 50000 low ## 3 David 60000 low ## 4 Eve 90000 high condition = df[&#39;employee&#39;] == &#39;David&#39; df[&#39;employee&#39;] = np.where(condition, &#39;Davut&#39;, df[&#39;employee&#39;]) df.head() ## employee salary label ## 0 Alice 70000 low ## 1 Bob 80000 low ## 2 Charlie 50000 low ## 3 Davut 60000 low ## 4 Eve 90000 high 5.4.8.2 multiple np.where() condition1 = df[&#39;salary&#39;] &lt;= 60000 condition2 = (df[&#39;salary&#39;] &gt; 60000) &amp; (df[&#39;salary&#39;] &lt;= 80000) df[&#39;label&#39;] = np.where(condition1, &#39;Low&#39;, &#39;High&#39;) df[&#39;label&#39;] = np.where(condition2, &#39;Medium&#39;, df[&#39;label&#39;]) df.head() ## employee salary label ## 0 Alice 70000 Medium ## 1 Bob 80000 Medium ## 2 Charlie 50000 Low ## 3 Davut 60000 Low ## 4 Eve 90000 High # Use np.where for multiple conditions condition_1 = df[&#39;salary&#39;] &lt;= 60000 condition_2 = df[&#39;salary&#39;] &lt;= 80000 df[&#39;label2&#39;] = np.where(condition_1, &#39;Low&#39;, np.where(condition_2, &#39;Medium&#39;, &#39;High&#39;) ) print(df) ## employee salary label label2 ## 0 Alice 70000 Medium Medium ## 1 Bob 80000 Medium Medium ## 2 Charlie 50000 Low Low ## 3 Davut 60000 Low Low ## 4 Eve 90000 High High ## 5 Frank 85000 High High ## 6 Grace 75000 Medium Medium ## 7 Hannah 65000 Medium Medium 5.4.8.3 pd.cut() method # Define thresholds for &#39;low&#39;, &#39;medium&#39;, and &#39;high&#39; earners bins = [0, 60000, 80000, float(&#39;inf&#39;)] labels = [&#39;Low&#39;, &#39;Medium&#39;, &#39;High&#39;] # Use pd.cut to create a new column &#39;category&#39; df[&#39;category&#39;] = pd.cut(df[&#39;salary&#39;], bins=bins, labels=labels) df.head() ## employee salary label label2 category ## 0 Alice 70000 Medium Medium Medium ## 1 Bob 80000 Medium Medium Medium ## 2 Charlie 50000 Low Low Low ## 3 Davut 60000 Low Low Low ## 4 Eve 90000 High High High 5.4.8.4 Alternative to np.where() 5.4.8.4.1 Using pd.Series.apply with a Lambda Function: if else condition df[&#39;high_low&#39;] = df[&#39;salary&#39;].apply(lambda x: &#39;high&#39; if x &gt; 85000 else &#39;low&#39;) 5.4.8.4.2 Using DataFrame.assign with np.where: df = df.assign(high_low2 = np.where(df[&#39;salary&#39;] &gt; 85000, &#39;high&#39;, &#39;low&#39;)) df.head() ## employee salary label label2 category high_low high_low2 ## 0 Alice 70000 Medium Medium Medium low low ## 1 Bob 80000 Medium Medium Medium low low ## 2 Charlie 50000 Low Low Low low low ## 3 Davut 60000 Low Low Low low low ## 4 Eve 90000 High High High high high 5.4.8.4.3 Using DataFrame.loc: df[&#39;new_label&#39;] = &#39;low&#39; df.loc[df[&#39;salary&#39;] &gt; 85000, &#39;new_label&#39;] = &#39;high&#39; 5.4.8.5 np.select() method data = { &#39;employee&#39;: [&#39;Alice&#39;, &#39;Bob&#39;, &#39;Charlie&#39;, &#39;David&#39;, &#39;Eve&#39;, &#39;Frank&#39;, &#39;Grace&#39;, &#39;Hannah&#39;], &#39;salary&#39;: [70000, 80000, 50000, 60000, 90000, 85000, 75000, 65000] } df = pd.DataFrame(data) # Define conditions for categorizing salaries conditions = [ (df[&#39;salary&#39;] &lt;= 60000), (df[&#39;salary&#39;] &gt; 60000) &amp; (df[&#39;salary&#39;] &lt;= 80000), (df[&#39;salary&#39;] &gt; 80000) ] # Corresponding choices for each condition choices = [&#39;Low&#39;, &#39;Medium&#39;, &#39;High&#39;] # Use np.select to create a new column &#39;earnings_category&#39; df[&#39;category2&#39;] = np.select(conditions, choices) df.head() ## employee salary category2 ## 0 Alice 70000 Medium ## 1 Bob 80000 Medium ## 2 Charlie 50000 Low ## 3 David 60000 Low ## 4 Eve 90000 High 5.4.8.6 apply() method # Custom function to categorize salary def categorize_salary(salary): if salary &lt;= 60000: return &#39;Low&#39; elif 60000 &lt; salary &lt;= 80000: return &#39;Medium&#39; else: return &#39;High&#39; # Apply the custom function to create a new column &#39;earnings_category&#39; df[&#39;category3&#39;] = df[&#39;salary&#39;].apply(categorize_salary) df.head() ## employee salary category2 category3 ## 0 Alice 70000 Medium Medium ## 1 Bob 80000 Medium Medium ## 2 Charlie 50000 Low Low ## 3 David 60000 Low Low ## 4 Eve 90000 High High "],["python-exercises.html", "Chapter 6 Python Exercises 6.1 Multiples of 3 - 5 6.2 Even Fibonacci numbers 6.3 Largest prime factor 6.4 Greatest Common Diviser 6.5 LinkedIN: sorting", " Chapter 6 Python Exercises 6.1 Multiples of 3 - 5 If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6, 9. The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5 below 1000. a = [x for x in range(1, 10) if (x%3==0 or x%5==0)] sum(a)==23 ## True b = [x for x in range(1, 1000) if (x%3==0 or x%5==0)] print(sum(b)) ## 233168 6.2 Even Fibonacci numbers Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be: 1, 2, 3, 5, 8, 13… By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms. fib_list = [1, 2] while True: x = fib_list[-1] + fib_list[-2] if x &gt; 4000000: break fib_list.append(x) even_sum = [x for x in fib_list if x%2==0] sum(even_sum) ## 4613732 6.3 Largest prime factor The prime factors of 13195 are 5, 7, 13 and 29. What is the largest prime factor of the number 600851475143? # primes = [1, 2] # # while True: # # for x in range(2, 10): # # x%i==0 6.4 Greatest Common Diviser def gcd(a, b): while b != 0: a, b = b, a % b return a # Example usage: print(gcd(55, 60)) # Output: 12 ## 5 6.5 LinkedIN: sorting Given a sorted array A of doubles. Compute a new sorted array B where each element is obtained by applying the following function f(x) (x is element in A) \\(f(x) = a*x^2 + b*x + c\\) Some values of a, b, c where a &gt; 0 Array A of sorted doubles x To solve this problem, you need to compute a new sorted array \\(B\\) from a sorted array \\(A\\) of doubles by applying a quadratic function \\(f(x) = ax^2 + bx + c\\) to each element \\(x\\) in \\(A\\). 6.5.1 Key Observations: Quadratic Function Shape: The function \\(f(x) = ax^2 + bx + c\\) is a parabola. It can open upwards (if \\(a &gt; 0\\)) or downwards (if \\(a &lt; 0\\)). Monotonic Behavior: Because \\(A\\) is already sorted, the quadratic function’s behavior on \\(A\\) depends on its vertex: If \\(a &gt; 0\\), the smallest value will be at the vertex, and the values will increase as you move away from it. If \\(a &lt; 0\\), the largest value will be at the vertex, and the values will decrease as you move away from it. Optimal Strategy: Two-pointer technique can help build the sorted array \\(B\\) without having to sort again. 6.5.2 Approach: Identify the direction of traversal: If \\(a &gt; 0\\): The smallest values will be on the sides of the array \\(A\\). Start filling \\(B\\) from the end. If \\(a &lt; 0\\): The largest values will be on the sides of the array \\(A\\). Start filling \\(B\\) from the beginning. Use Two Pointers: Initialize two pointers, left at the start of \\(A\\) and right at the end. Compute \\(f(x)\\) for both A[left] and A[right]. Compare the two values and place the appropriate one in \\(B\\). 6.5.3 Python Code Implementation: def compute_sorted_array(A, a, b, c): # Define the quadratic function def f(x): return a * x ** 2 + b * x + c # Initialize pointers for the original sorted array A left, right = 0, len(A) - 1 # Initialize the result array B of the same size as A B = [0] * len(A) # Index to fill in B (depends on whether a &gt; 0 or a &lt; 0) index = len(A) - 1 if a &gt; 0 else 0 # Two pointer approach to fill B while left &lt;= right: left_val = f(A[left]) right_val = f(A[right]) if a &gt; 0: # Parabola opens upwards, fill B from the end if left_val &gt; right_val: B[index] = left_val left += 1 else: B[index] = right_val right -= 1 index -= 1 else: # Parabola opens downwards, fill B from the beginning if left_val &lt; right_val: B[index] = left_val left += 1 else: B[index] = right_val right -= 1 index += 1 return B # Example usage: A = [-4, -2, 0, 1, 3] a, b, c = 1, 2, 1 B = compute_sorted_array(A, a, b, c) print(B) # Output will be a sorted array B after applying f(x) 6.5.4 Explanation: The function f(x) calculates the quadratic value. We use a two-pointer technique to determine whether to take from the left or right of \\(A\\) based on the computed values. Depending on the value of \\(a\\), we either start filling \\(B\\) from the end or from the beginning to maintain the sorted order. This approach runs in \\(O(n)\\) time complexity since it only requires a single pass through the array \\(A\\). 6.5.5 Question Given a sorted array A of doubles. Compute a new sorted array B where each element is obtained by applying the following function f(x) (x is element in A) \\(f(x) = a*x^2 + b*x + c\\) Some values of a, b, c where a &gt; 0 Array A of sorted doubles x To compute a new sorted array \\(B\\) from a sorted array \\(A\\) of doubles, where each element of \\(B\\) is the result of applying a quadratic function \\(f(x) = ax^2 + bx + c\\) to the corresponding element in \\(A\\), we can use the following approach. Since \\(a &gt; 0\\), the quadratic function is a parabola that opens upwards, meaning it will have a minimum point (vertex). Depending on where this vertex lies relative to the values in array \\(A\\), the sorted order of \\(B\\) can differ. 6.5.6 Approach: Identify the Vertex of the Parabola: The function \\(f(x) = ax^2 + bx + c\\)has a vertex at \\(x = -\\frac{b}{2a}\\). Determine where this vertex lies in relation to the values in the sorted array \\(A\\). Two-Pointer Technique: Since array \\(A\\) is sorted, we know the order of elements in \\(A\\). Depending on whether the function is increasing or decreasing, we can build the sorted array \\(B\\) efficiently. Initialize two pointers: left at the start of the array \\(A\\) (smallest value) and right at the end of the array \\(A\\) (largest value). Create an array \\(B\\) of the same size as \\(A\\) to store the results. If the function values tend to grow larger on both sides, we start filling \\(B\\) from the end to the beginning (since \\(a &gt; 0\\), it will form a U-shaped parabola). Construct the Sorted Array \\(B\\): Compare the values of \\(f(A[left])\\) and \\(f(A[right])\\). If \\(f(A[left]) &gt; f(A[right])\\), place \\(f(A[left])\\) in the current position of \\(B\\) from the end, and move the left pointer to the right. Otherwise, place \\(f(A[right])\\) in the current position of \\(B\\) from the end, and move the right pointer to the left. Repeat the process until the left pointer crosses the right pointer. 6.5.7 Pseudo-code: def computeSortedArray(A, a, b, c): # Function to compute f(x) = ax^2 + bx + c def f(x): return a * x * x + b * x + c n = len(A) B = [0] * n # Initialize array B left, right = 0, n - 1 index = n - 1 # Start filling B from the end # Two-pointer technique to fill B while left &lt;= right: left_val = f(A[left]) right_val = f(A[right]) if left_val &gt; right_val: B[index] = left_val left += 1 else: B[index] = right_val right -= 1 index -= 1 return B 6.5.8 Example: Given: \\(A = [-3, -1, 0, 1, 2]\\) \\(a = 1, b = 0, c = 0\\) Function: \\(f(x) = x^2\\) Steps: Calculate \\(f(x)\\) for each element in \\(A\\): \\(f(-3) = 9\\) \\(f(-1) = 1\\) \\(f(0) = 0\\) \\(f(1) = 1\\) \\(f(2) = 4\\) Resulting array in sorted order by filling from the highest index: \\(B = [0, 1, 1, 4, 9]\\) 6.5.9 Summary: The approach efficiently computes the sorted transformed array \\(B\\) in \\(O(n)\\) time using the two-pointer technique. This approach takes advantage of the fact that the input array \\(A\\) is sorted and that the parabola opens upwards, simplifying the sorting process of the transformed values. "],["big-o-notation.html", "Chapter 7 Big O notation", " Chapter 7 Big O notation In computer science, Big O notation is used to describe the time complexity (or space complexity) of an algorithm. It provides an upper bound on the time (or space) required by an algorithm relative to the size of the input data as the input size grows. It helps us understand the worst-case scenario performance and scalability of an algorithm. 7.0.1 Common Big O Notations: O(1) - Constant Time Complexity: An algorithm is said to have constant time complexity when its running time does not depend on the size of the input data. This means that no matter how large the input is, the algorithm will always take the same amount of time to complete. Example: Accessing an element in an array by index, such as arr[5], is an \\(O(1)\\) operation because it takes the same amount of time regardless of the array size. O(log n) - Logarithmic Time Complexity: An algorithm is said to have logarithmic time complexity if it reduces the problem size by half at each step. These algorithms are very efficient, especially for large datasets. Example: Binary search on a sorted array is \\(O(\\log n)\\) because it divides the search space in half with each step. O(n) - Linear Time Complexity: An algorithm has linear time complexity when its running time increases linearly with the size of the input. In other words, if the input size doubles, the running time will also double. Example: A simple loop that iterates through all elements in an array has \\(O(n)\\) time complexity. O(n n) - Linearithmic Time Complexity: An algorithm has linearithmic time complexity when its running time is a combination of linear and logarithmic complexities. These are typical of algorithms that perform some kind of divide-and-conquer approach. Example: Efficient sorting algorithms like Merge Sort and Quick Sort have \\(O(n \\log n)\\) time complexity. O(n^2) - Quadratic Time Complexity: An algorithm has quadratic time complexity when its running time is proportional to the square of the size of the input. If the input size doubles, the running time quadruples. Example: A nested loop that iterates over all pairs of elements in an array has \\(O(n^2)\\) time complexity. A classic example is the Bubble Sort algorithm. O(n^3) - Cubic Time Complexity: An algorithm with cubic time complexity involves three nested loops and grows even more quickly as input size increases. Example: A triple nested loop iterating over three different dimensions, like calculating all combinations of three elements from a list. O(2^n) - Exponential Time Complexity: An algorithm has exponential time complexity when the growth rate doubles with each additional element in the input. These algorithms are generally very inefficient and not feasible for large input sizes. Example: Solving the Traveling Salesman Problem using brute force or generating all subsets of a set (the power set). O(n!) - Factorial Time Complexity: An algorithm has factorial time complexity when it grows factorially with the input size. These algorithms are typically only used for very small input sizes due to their extreme inefficiency. Example: Solving the Traveling Salesman Problem by checking all possible permutations. 7.0.2 Summary Table: Big O Notation Name Example Use Case \\(O(1)\\) Constant Array element access by index \\(O(\\log n)\\) Logarithmic Binary search \\(O(n)\\) Linear Linear search, single loop over elements \\(O(n \\log n)\\) Linearithmic Merge Sort, Quick Sort \\(O(n^2)\\) Quadratic Bubble Sort, Selection Sort \\(O(n^3)\\) Cubic Triple nested loops \\(O(2^n)\\) Exponential Recursive solutions to combinatorial problems \\(O(n!)\\) Factorial Permutations of a set 7.0.3 Key Takeaways: Lower-order terms and constants are generally omitted in Big O notation (e.g., \\(O(2n)\\) is considered \\(O(n)\\)). Big O provides a high-level understanding of an algorithm’s performance. Understanding the time complexity helps in choosing the right algorithm for a given problem, especially when dealing with large datasets. By learning these common Big O notations, you can better analyze the efficiency of different algorithms and data structures! "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
