[["index.html", "Python Scratch Book Acknowledgement", " Python Scratch Book Davut Ayan 2024-02-14 Acknowledgement This is a personal notebook open for public use. I have collected these notes, codes and best practices that I find useful to remind myself on python programming language. All these content are free to use and share. "],["intro.html", "Chapter 1 Introduction 1.1 Basics: 1.2 Collections 1.3 Data Types 1.4 Control Statements", " Chapter 1 Introduction Python Python is what is called an interpreted language. Compiled languages examine your entire program at compile time, and are able to warn you about a whole class of errors prior to execution. In contrast, Python interprets your script line by line as it executes it. Python will stop executing the entire program when it encounters an error (unless the error is expected and handled by the programmer, a more advanced subject that we’ll cover later on in this course). Jupyter Lab to install on mac: pip3 install jupyterlab on terminal to upgrade pip: pip3 install --upgrade pip on terminal check python version !python -V # Check the Python Version import sys print(sys.version) ## 3.10.3 (v3.10.3:a342a49189, Mar 16 2022, 09:34:18) [Clang 13.0.0 (clang-1300.0.29.30)] [Tip:] sys is a built-in module that contains many system-specific parameters and functions, including the Python version in use. Before using it, we must explicitly import it. In Python, the concepts of objects and data types are closely related. In fact, in Python, everything is an object. Understanding this relationship is key to working effectively with Python. 1.1 Basics: 1.1.1 Objects vs Data Types 1.1.1.1 Objects in Python: Everything is an Object: In Python, every value is an object, and every object has a type. This includes not only the fundamental data types (integers, floats, strings) but also more complex types like lists, dictionaries, and even functions. Object Identity: Each object in Python has a unique identity, which can be obtained using the id() function. This identity is guaranteed to be unique and constant for the lifetime of the object. Object Attributes and Methods: Objects in Python can have attributes (characteristics) and methods (functions associated with the object). For example, a string object has methods like upper() and attributes like length. 1.1.1.2 Data Types in Python: Type of an Object: The type of an object in Python represents the kind of data that the object can hold. For example, the types int, float, str, etc., represent different categories of data. Type Checking: You can use the type() function to determine the type of an object. For example: x = 5 print(type(x)) # Output: &lt;class &#39;int&#39;&gt; Dynamic Typing: Python is dynamically typed, which means you don’t have to explicitly declare the type of a variable. The type is determined at runtime. 1.1.1.3 Relationship: Every value in Python is an object, and every object has a type. For example, 5 is an object of type int. Data types in Python are essentially classes, and objects are instances of those classes. When you create a variable, you are creating an instance of a specific data type (class). You can think of data types as categories or blueprints for objects. They define the behavior and characteristics of objects. In summary, in Python, objects are instances of data types. The term “data type” refers to the category or class of the object, and objects are specific instances of these types. Understanding this distinction is fundamental to writing effective and readable Python code. 1.1.2 Objects in Python In Python, everything is an object. Objects are instances of classes, and Python is an object-oriented programming language. Here are some common types of objects in Python: Numbers: int: Integer type, e.g., x = 5. float: Floating-point type, e.g., y = 3.14. complex: Complex number type, e.g., z = 2 + 3j. x = 3.4 print(&quot;Integer type&quot;, int(x)) ## Integer type 3 print(&quot;Float type&quot;, float(x)) ## Float type 3.4 print(&quot;Complex type&quot;, complex(x)) ## Complex type (3.4+0j) Strings: str: String type, e.g., s = \"Hello, World!\". Collections: list: Ordered collection of items, e.g., my_list = [1, 2, 3]. tuple: Immutable ordered collection of items, e.g., my_tuple = (1, 2, 3). set: Unordered collection of unique items, e.g., my_set = {1, 2, 3}. dict: Key-value pairs, e.g., my_dict = {'a': 1, 'b': 2}. Boolean: bool: Boolean type, representing True or False. x = True y = False print(type(x)) ## &lt;class &#39;bool&#39;&gt; None: None: A special object representing the absence of a value or a null value. x = None print(type(x)) ## &lt;class &#39;NoneType&#39;&gt; Functions: Functions themselves are objects in Python. You can assign them to variables, pass them as arguments, and return them from other functions. Classes: User-defined classes create objects. Instances of a class are objects. Modules: Modules are also objects. When you import a module, you are working with an object. File Objects: When you open a file, the file itself is an object in Python. Exceptions: Exception instances are objects that represent exceptional conditions. Custom Objects: Objects created from user-defined classes. In Python, you can use the type() function to determine the type of an object, and the isinstance() function to check if an object is an instance of a particular class. The dynamic typing nature of Python allows objects to change types during runtime. There are many different types of objects in Python. Let’s start with the most common object types: strings, integers and floats. Anytime you write words (text) in Python, you’re using character strings (strings for short). The most common numbers, on the other hand, are integers (e.g. -1, 0, 100) and floats, which represent real numbers (e.g. 3.14, -42.0). 1.2 Collections list: Ordered collection of items, e.g., my_list = [1, 2, 3]. tuple: Immutable ordered collection of items, e.g., my_tuple = (1, 2, 3). set: Unordered collection of unique items, e.g., my_set = {1, 2, 3}. dict: Key-value pairs, e.g., my_dict = {'a': 1, 'b': 2}. 1.2.1 Properties In Python, collections are built-in data types that can be used to group multiple elements together. Here are some common properties of Python collections: Mutable vs. Immutable: Mutable Collections: Lists (list), Sets (set), and Dictionaries (dict) are mutable. You can modify their contents after creation. Immutable Collections: Tuples (tuple) and Strings (str) are immutable. Once created, their contents cannot be changed. Ordering: Ordered Collections: Lists and Tuples maintain the order of elements. Elements are stored in the order they were added. Unordered Collections: Sets and Dictionaries do not guarantee any specific order. The order of elements may not be the same as the order of insertion. Indexing and Slicing: Indexing: Lists, Tuples, and Strings support indexing. Elements can be accessed using indices (0-based). my_list = [1, 2, 3, 4] print(my_list[0]) # Output: 1 Slicing: Lists, Tuples, and Strings support slicing to create sub-collections. my_string = &quot;Hello, World!&quot; print(my_string[0:5]) # Output: Hello Uniqueness: Unique Elements: Sets only contain unique elements. If you try to add an element that already exists, it won’t be added again. my_set = {1, 2, 3, 1} print(my_set) # Output: {1, 2, 3} Key-Value Pairs (Dictionaries): Associative Data: Dictionaries consist of key-value pairs, allowing you to associate values with unique keys. my_dict = {&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 30, &#39;city&#39;: &#39;New York&#39;} print(my_dict[&#39;age&#39;]) # Output: 30 Heterogeneity: Mixed Types: Lists, Tuples, and Sets can contain elements of different data types. my_list = [1, &#39;apple&#39;, 3.14] Size and Length: Size: Lists, Tuples, and Strings have a fixed size once created. Elements can be added or removed, but the overall size remains constant. Dynamic Size: Sets and Dictionaries can dynamically grow or shrink in size. Common Operations: Adding Elements: append(), extend(), add() Removing Elements: remove(), pop(), discard(), clear() Checking Membership: in keyword Length: len() Understanding these properties helps you choose the right collection for a particular use case and use collections effectively in your Python programs. 1.2.1.1 Extra: Imuutable Yes, in Python, strings are immutable objects. This means that once a string is created, you cannot change its content. Any operation that appears to modify a string actually creates a new string. This immutability has several implications: No In-Place Modifications: You cannot modify a string directly by changing a character at a specific index, like you can with a list. my_string = &quot;Hello&quot; # The following will result in an error my_string[0] = &#39;J&#39; Creating New Strings: Operations like concatenation or slicing create new strings rather than modifying the original. original_string = &quot;Hello&quot; new_string = original_string + &quot;, World!&quot; Hashing: Because strings are immutable, they can be used as keys in dictionaries and elements in sets. Their hash value remains constant. my_set = {&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;} Memory Efficiency: Python can optimize memory usage by reusing the same string in memory if it already exists, thanks to immutability. a = &quot;Hello&quot; b = &quot;Hello&quot; # Both a and b refer to the same string object in memory Understanding the immutability of strings is important when working with them in Python to avoid unexpected behavior and to write efficient and correct code. If you need to modify a string, you typically create a new string with the desired changes. 1.2.2 1. lists A list is a sequenced collection of different objects such as integers, strings, and even other lists as well. The address of each element within a list is called an index. An index is used to access and refer to items within a list. Lists can contain strings, floats, and integers. We can nest other lists, and we can also nest tuples and other data structures. The same indexing conventions apply for nesting: list are like tuples, ordered sequences. But lists are mutable. A list is a built-in data type used to store an ordered collection of items. Lists are mutable, which means you can modify their contents by adding, removing, or changing elements. Lists are defined using square brackets []. Here’s an overview of lists and some example methods: 1.2.2.1 Creating Lists: x = [] ## empty list print(x) ## [] my_list = [1, 2, 3, &#39;apple&#39;, &#39;banana&#39;, &#39;cherry&#39;] print(my_list) ## [1, 2, 3, &#39;apple&#39;, &#39;banana&#39;, &#39;cherry&#39;] 1.2.2.2 Common List Methods: Accessing # Accessing by index first_element = my_list[0] # Result: 1 # Slicing subset = my_list[1:4] # Result: [2, 3, &#39;apple&#39;, &#39;banana&#39;] Append (append()): Adds an element to the end of the list. my_list.append(&quot;XXXX&quot;) print(my_list) ## [1, 2, 3, &#39;apple&#39;, &#39;banana&#39;, &#39;cherry&#39;, &#39;XXXX&#39;] Extend (extend()): Extends the list by appending elements from another iterable. another_list = [5, 6, 7] my_list.extend(another_list) print(my_list) ## [1, 2, 3, &#39;apple&#39;, &#39;banana&#39;, &#39;cherry&#39;, &#39;XXXX&#39;, 5, 6, 7] Insert (insert()): Inserts an element at a specified position. this is not replacing !!! my_list.insert(2, &#39;orange&#39;) print(my_list) ## [1, 2, &#39;orange&#39;, 3, &#39;apple&#39;, &#39;banana&#39;, &#39;cherry&#39;, &#39;XXXX&#39;, 5, 6, 7] Remove (remove()): Removes the first occurrence of a specified value. my_list.remove(&#39;banana&#39;) print(my_list) ## [1, 2, &#39;orange&#39;, 3, &#39;apple&#39;, &#39;cherry&#39;, &#39;XXXX&#39;, 5, 6, 7] Pop (pop()): Removes and returns the element at the specified index. If no index is provided, it removes the last element. popped_element = my_list.pop(2) print(popped_element) ## orange Index (index()): Returns the index of the first occurrence of a specified value. index_of_apple = my_list.index(&#39;apple&#39;) print(index_of_apple) ## 3 Count (count()): Returns the number of occurrences of a specified value. count_of_cherry = my_list.count(&#39;cherry&#39;) print(count_of_cherry) ## 1 Sort (sort()): Sorts the list in ascending order. Optionally, you can specify reverse=True for descending order. # Convert all elements to strings before sorting st_list = [str(x) for x in my_list] st_list.sort() print(st_list) ## [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;XXXX&#39;, &#39;apple&#39;, &#39;cherry&#39;] # Convert all elements to strings before sorting sorted_list = sorted(map(str, my_list)) print(sorted_list) ## [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;XXXX&#39;, &#39;apple&#39;, &#39;cherry&#39;] Reverse (reverse()): Reverses the order of the elements in the list. my_list.reverse() print(my_list) ## [7, 6, 5, &#39;XXXX&#39;, &#39;cherry&#39;, &#39;apple&#39;, 3, 2, 1] Concatenate lists a_list = [1, 2, 3] b_list = [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;] print(a_list + b_list) ## [1, 2, 3, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;] loop thru a list a = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] for item in a: print(item.upper()) ## A ## B ## C 1.2.3 2. tuples Tuples are an ordered sequences of items, just like lists. The main difference between tuples and lists is that tuples cannot be changed (immutable) unlike lists which can (mutable). tuples are collection of different type of objects. Empty tuples a = () b = tuple() Create tuples ## 1. way a_tuple = (1, 2.5, &quot;string&quot;, [3, 4]) b = (1,) print(b) ## (1,) Concatenate tuples b_tuple = (&quot;a&quot;, &quot;ab&quot;) print(a_tuple + b_tuple) ## (1, 2.5, &#39;string&#39;, [3, 4], &#39;a&#39;, &#39;ab&#39;) Immutable element of a tuple can not be changed a_tuple = (1,2,3,4,5) a_tuple[5] = &quot;a&quot; # TypeError: &#39;tuple&#39; object does not support item assignment sorted function sorted() function: We can sort the tuple and assign a new name sorted() function returns list type. a_tuple = (1, 5, 2, 7, 4) x = sorted(a_tuple) print(x) ## [1, 2, 4, 5, 7] Nesting we can create nested tuples. nested = (1, 2, (&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), (&quot;ayan&quot;, (4, 5))) nested[2] ## (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;) 1.2.3.1 tuple methods index method The index method returns the first index at which a value occurs. a = (&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) a.index(&quot;c&quot;) ## 2 count method The count method returns the number of times a value occurs in a tuple. a = (&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;b&quot;) a.count(&quot;b&quot;) ## 3 loop thru a tuple a = (&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) for item in a: print(item) ## a ## b ## c ## d ## a ## b ## c ## d 1.2.4 3. Sets Sets in Python are unordered collections of unique elements. Unlike lists, sets do not have a specific order, and each element in a set must be unique. Here are some common operations and methods associated with sets: Creating Sets my_set = {1, 2, 3, 4, 5} Adding Elements my_set.add(6) # Adds the element 6 to the set Removing Elements my_set.remove(3) # Removes the element 3 from the set Set Operations set1 = {1, 2, 3, 4, 5} set2 = {3, 4, 5, 6, 7} # Union union_set = set1.union(set2) # Result: {1, 2, 3, 4, 5, 6, 7} # Intersection intersection_set = set1.intersection(set2) # Result: {3, 4, 5} # Difference difference_set = set1.difference(set2) # Result: {1, 2} # Symmetric Difference symmetric_difference_set = set1.symmetric_difference(set2) # Result: {1, 2, 6, 7} 1.2.4.1 Set Methods # Discard an element (if it exists) my_set.discard(4) # Clear all elements my_set.clear() # Copying a set copy_of_set = my_set.copy() Other Operations # Checking Membership is_present = 5 in my_set # Result: True # Length of a Set length_of_set = len(my_set) Sets are useful when you need to work with unique elements, perform set operations, or check for membership efficiently. They do not support indexing or slicing, as they are unordered. Additionally, sets are mutable, meaning you can add and remove elements, but individual elements must be immutable (e.g., numbers, strings). 1.2.5 Dictionary Dictionaries in Python are collections of key-value pairs, where each key must be unique. Dictionaries are versatile and used for mapping values to unique keys. Here are common operations and methods associated with dictionaries: Creating Dictionaries my_dict = {&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 30, &#39;city&#39;: &#39;New York&#39;} print(my_dict) ## {&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 30, &#39;city&#39;: &#39;New York&#39;} Accessing Values # Accessing by key p0 = my_dict[&#39;name&#39;] # Result: &#39;John&#39; print(p0) ## John # Using the get() method p1 = my_dict.get(&#39;name&#39;) # Result: 30 print(p1) ## John Modifying Dictionaries # Updating a value my_dict[&#39;age&#39;] = 31 # Adding a new key-value pair my_dict[&#39;gender&#39;] = &#39;Male&#39; Removing Items # Removing a key-value pair del my_dict[&#39;city&#39;] my_dict = {&#39;name&#39;: &#39;John&#39;, &#39;age&#39;: 30, &#39;gender&#39;: &#39;Male&#39;} # Using the pop() method gender = my_dict.pop(&#39;gender&#39;) # Removes the &#39;gender&#39; key and returns its value print(gender) ## Male 1.2.5.1 Dictionary Methods: # Getting all keys keys = my_dict.keys() # Result: [&#39;name&#39;, &#39;age&#39;] print(keys) ## dict_keys([&#39;name&#39;, &#39;age&#39;]) # Getting all values values = my_dict.values() # Result: [&#39;John&#39;, 31] print(values) ## dict_values([&#39;John&#39;, 30]) # Getting all key-value pairs as tuples items = my_dict.items() # Result: [(&#39;name&#39;, &#39;John&#39;), (&#39;age&#39;, 31)] print(items) ## dict_items([(&#39;name&#39;, &#39;John&#39;), (&#39;age&#39;, 30)]) 1.2.6 Iterating Over a Dictionary: for key in my_dict: print(key, my_dict[key]) ## name John ## age 30 1.2.7 Other Operations: # Checking Membership (in terms of keys) is_present = &#39;age&#39; in my_dict # Result: True # Length of a Dictionary length_of_dict = len(my_dict) Dictionaries are widely used in Python for tasks that involve mapping keys to values, such as representing data structures, configuration settings, and more. They are mutable, meaning you can modify their contents by adding, updating, or removing key-value pairs. The keys must be immutable (e.g., strings, numbers), but the values can be of any type. 1.3 Data Types In Python, data types are classifications that specify which type of value a variable can hold. Here are some of the basic and commonly used data types in Python: Numeric Types: int: Integer type, e.g., x = 5. float: Floating-point type, e.g., y = 3.14. complex: Complex number type, e.g., z = 2 + 3j. Text Type: str: String type, e.g., s = \"Hello, World!\". Sequence Types: list: Ordered collection of items, e.g., my_list = [1, 2, 3]. tuple: Immutable ordered collection of items, e.g., my_tuple = (1, 2, 3). Set Types: set: Unordered collection of unique items, e.g., my_set = {1, 2, 3}. frozenset: Immutable version of a set. Mapping Type: dict: Dictionary, a collection of key-value pairs, e.g., my_dict = {'a': 1, 'b': 2}. Boolean Type: bool: Boolean, representing True or False. None Type: NoneType (None): A special type representing the absence of a value or a null value. Binary Types: bytes: Immutable sequence of bytes, e.g., b = b'hello'. bytearray: Mutable sequence of bytes. memoryview: A view object that exposes an array’s buffer interface. These data types are the building blocks for creating variables, structures, and performing various operations in Python. You can use the type() function to check the type of a variable or value. For example: x = 5 print(type(x)) # Output: &lt;class &#39;int&#39;&gt; y = 3.14 print(type(y)) # Output: &lt;class &#39;float&#39;&gt; s = &quot;Hello, World!&quot; print(type(s)) # Output: &lt;class &#39;str&#39;&gt; Understanding and working with these data types is fundamental to writing Python code. Keep in mind that Python is dynamically typed, meaning you don’t need to explicitly declare the data type of a variable; it is determined at runtime. 1.3.1 Numeric Types 1.3.1.1 Mathematical Operations Python supports a variety of mathematical operations, which can be performed on numerical data types. Here are some common mathematical operations in Python: 1.3.1.2 Arithmetic Operations: Addition (+): result = 5 + 3 # result is 8 Subtraction (-): result = 5 - 3 # result is 2 Multiplication (*): result = 5 * 3 # result is 15 Division (/): result = 6 / 3 # result is 2.0 (float) Floor Division (//): result = 7 // 3 # result is 2 (integer division) Modulus (%): result = 7 % 3 # result is 1 (remainder after division) Exponentiation (**): result = 2 ** 3 # result is 8 (2 to the power of 3) 1.3.1.3 Comparison Operations: Equal to (==): result = (5 == 3) # result is False Not equal to (!=): result = (5 != 3) # result is True Greater than (&gt;): python result = (5 &gt; 3) # result is True Less than (&lt;): python result = (5 &lt; 3) # result is False Greater than or equal to (&gt;=): python result = (5 &gt;= 3) # result is True Less than or equal to (&lt;=): python result = (5 &lt;= 3) # result is False 1.3.2 Other Mathematical Functions: Absolute Value (abs()): python result = abs(-5) # result is 5 Round (round()): python result = round(3.14159, 2) # result is 3.14 (rounded to 2 decimal places) Minimum (min())/Maximum (max()): python minimum = min(1, 2, 3) # minimum is 1 maximum = max(1, 2, 3) # maximum is 3 These are just a few examples, and Python provides a rich set of mathematical functions and operations through the math module as well. To use it, you can import the math module and access functions like math.sqrt(), math.sin(), math.cos(), etc. import math # Square root result = math.sqrt(16) # result is 4.0 # Trigonometric functions (input in radians) sin_result = math.sin(math.radians(30)) # result is 0.5 (sin of 30 degrees) cos_result = math.cos(math.radians(60)) # result is 0.5 (cos of 60 degrees) tan_result = math.tan(math.radians(45)) # result is 1.0 (tan of 45 degrees) # Logarithmic functions log_result = math.log(100, 10) # result is 2.0 (log base 10 of 100) # Exponential function exp_result = math.exp(2) # result is approximately 7.389 # Constants pi_value = math.pi # value of pi (3.141592653589793) euler_number = math.e # Euler&#39;s number (2.718281828459045) # Other functions factorial_result = math.factorial(5) # result is 120 (5!) 1.3.3 Converting data types numeric to string a = 5.5 b = str(a) string to numeric float(&quot;1.1&quot;) ## 1.1 it does not convert directly to integer here int(&quot;1.123&quot;) but it works when transforming to float then integer. int(float(&quot;10.123&quot;)) boolean to numeric True becomes 1 bl = True int(bl) ## 1 numeric to boolean 0 becomes False all other numbers are True bool(-100) ## True bool(0) ## False 1.3.4 Strings A string is a sequence of characters, and it is one of the basic data types used to represent text. Strings are enclosed in either single quotes (') or double quotes (\"), and you can use either as long as the opening and closing quotes match. Here are some key characteristics and operations related to strings in Python: Creating Strings # Using single quotes single_quoted_string = &#39;Hello, Python!&#39; # Using double quotes double_quoted_string = &quot;Hello, Python!&quot; # Triple-quoted strings for multiline strings multiline_string = &#39;&#39;&#39;This is a multiline string.&#39;&#39;&#39; String Concatenation first_name = &quot;John&quot; last_name = &quot;Doe&quot; full_name = first_name + &quot; &quot; + last_name print(full_name) ## John Doe String Indexing and Slicing my_string = &quot;Python&quot; # Indexing (0-based) first_char = my_string[0] # Result: &#39;P&#39; print(first_char) ## P syntax: string_object[from : to : increment] # Slicing substring = my_string[1:4:1] # Result: &#39;yth&#39; substring = my_string[1:4] # Result: &#39;yth&#39; print(substring) ## yth print(my_string[::2]) ## Pto 1.3.4.1 String Methods: # Length of a string length = len(my_string) # Result: 6 # Converting to uppercase and lowercase uppercase_string = my_string.upper() lowercase_string = my_string.lower() # Finding a substring index_of_th = my_string.find(&quot;th&quot;) # Result: 2 # Replacing a substring new_string = my_string.replace(&quot;on&quot;, &quot;er&quot;) # Result: &#39;Pyther&#39; upper() : strings to uppercase lower() : strings to lowercase capitalize() : strings to uppercase 1st letter &quot;Ohh! my life!&quot;.upper() ## &#39;OHH! MY LIFE!&#39; &quot;OHH! MY LIFE!&quot;.lower() ## &#39;ohh! my life!&#39; &quot;star&quot;.capitalize() ## &#39;Star&#39; &quot;is it lowercase&quot;.islower() ## True &quot;IS IT UPPERCASE&quot;.isupper() ## True replace method replace(): to replace part of a string syntax: string.replace(oldvalue, newvalue, count) query = &#39;&#39;&#39; select all_columns from my_table &#39;&#39;&#39; new_query = query.replace(&quot;my_table&quot;, &quot;new_table_name&quot;) print(new_query) ## ## select all_columns ## from new_table_name strip method strip() method removes leading or trailing white-space raw_text = &quot; my text &quot; raw_text.strip() ## &#39;my text&#39; split method split() method breaks a string by specified character. split() method returns list type. raw_text = &quot;banana, apple, cherry&quot; alist = raw_text.split(&quot;,&quot;) alist ## [&#39;banana&#39;, &#39; apple&#39;, &#39; cherry&#39;] there are some whitespce in the splitted elements in the list alist[1].strip() ## &#39;apple&#39; 1.3.4.2 String Formatting: name = &quot;Alice&quot; age = 25 formatted_string = f&quot;My name is {name} and I am {age} years old.&quot; # Result: &#39;My name is Alice and I am 25 years old.&#39; 1.3.4.3 Escape Characters: escaped_string = &quot;This is a line.\\nThis is a new line.\\tThis is a tab.&quot; print(escaped_string) ## This is a line. ## This is a new line. This is a tab. 1.3.4.4 Raw Strings: raw_string = r&quot;This is a raw string \\n\\t No escape characters here.&quot; print(raw_string) ## This is a raw string \\n\\t No escape characters here. 1.3.4.5 Membership and Operations: # Checking membership contains_py = &#39;py&#39; in my_string # Result: True # String repetition repeated_string = my_string * 3 # Result: &#39;PythonPythonPython&#39; Strings in Python are immutable, meaning once a string is created, you cannot modify its contents. Any operation that appears to modify a string actually creates a new string. Understanding these operations and methods is crucial for working effectively with strings in Python. 1.3.4.6 loop thru strings my_txt = &quot;life&quot; for i in my_txt: print(i.upper()) ## L ## I ## F ## E 1.3.4.7 in/not in check if a phrase is present in a string my_txt = &quot;life is good!&quot; print(&quot;good&quot; in my_txt) ## True if &quot;good&quot; in my_txt: print(my_txt) ## life is good! if &quot;bad&quot; not in my_txt: print(&quot;&#39;bad&#39; is not in the text&quot;) ## &#39;bad&#39; is not in the text 1.4 Control Statements 1.4.1 Looping 1.4.2 Looping Extra for-else for i in range(5): break else: print(&#39;else runs cus break didnt run&#39;) In a for-else block, if break runs in the for loop, else doesn’t run if break doesn’t run in the for loop, else will run break vs continue break stops the entire loop immediately when L=‘C’, break happens, and the entire loop stops. LETTERS = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;] for L in LETTERS: if L == &#39;C&#39;: break print(L) ## A ## B continue skips to the next iteration, without stopping the entire loop LETTERS = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;] for L in LETTERS: if L == &#39;C&#39;: continue print(L) ## A ## B ## D ## E when L='C', continue executes, and the iteration for L='C' is skipped. Instead we skip over to the next iteration immediately, where L='D' Note that continue doesn’t stop the entire loop like break enumerate &amp; zip enumerate() allows us to generate both index and element at the same time when iterating through a list (or similar iterable). LETTERS = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;] for i,L in enumerate(LETTERS): print(i, L) ## 0 A ## 1 B ## 2 C ## 3 D ## 4 E zip() allows us to iterate through 2 or more lists (or iterables) at once. names = [&#39;Adam&#39;, &#39;Eve&#39;, &#39;Joe&#39;] ages = [25,35,18] for name, age in zip(names, ages): print(name, age) ## Adam 25 ## Eve 35 ## Joe 18 "],["pandas-library.html", "Chapter 2 Pandas Library 2.1 Data Frames 2.2 read data", " Chapter 2 Pandas Library run pip3 install pandas or run !pip install pandas on rstudio terminal or mac terminal or jupyter notebook import pandas as pd pd.set_option(&#39;display.max_columns&#39;, None) 2.1 Data Frames 2.1.1 Data frame creation Sometimes you may need to create an data frame ## empty data frame df1 = pd.DataFrame() df1 ## Empty DataFrame ## Columns: [] ## Index: [] df2 = pd.DataFrame({&#39;A&#39; : []}) df2 ## Empty DataFrame ## Columns: [A] ## Index: [] Is df2 empty? There is column name but it is still empty. df2.empty ## True How to create a sample data frame? From a dictionary my_dict = {&#39;Col_1&#39;: [1,2,3,4], &#39;Col_2&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;], &#39;Col_3&#39;: 1984} my_df = pd.DataFrame(my_dict) my_df[:5] ## Col_1 Col_2 Col_3 ## 0 1 a 1984 ## 1 2 b 1984 ## 2 3 c 1984 ## 3 4 d 1984 a_list = [1,2,3,4] b_list = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] ## df3 = pd.DataFrame({&#39;var1&#39;: a_list, &#39;var2&#39;: b_list}) df3 ## var1 var2 ## 0 1 a ## 1 2 b ## 2 3 c ## 3 4 d 2.1.2 Read csv files df_csv = pd.read_csv(&#39;data/college.csv&#39;).iloc[:100, :5] df_csv[:5] ## id name city state region ## 0 102669 Alaska Pacific University Anchorage AK West ## 1 101648 Marion Military Institute Marion AL South ## 2 100830 Auburn University at Montgomery Montgomery AL South ## 3 101879 University of North Alabama Florence AL South ## 4 100858 Auburn University Auburn AL South 2.1.3 Data attributes 2.1.3.1 shape of data frame df_csv.shape ## (100, 5) print(&quot;number of rows:&quot;, df_csv.shape[0], &quot;\\nnumber of columns:&quot;, df_csv.shape[1]) ## number of rows: 100 ## number of columns: 5 2.1.3.2 Columns How to get the column names? –&gt; Column names are stored in columns attribute. df_csv.columns ## Index([&#39;id&#39;, &#39;name&#39;, &#39;city&#39;, &#39;state&#39;, &#39;region&#39;], dtype=&#39;object&#39;) list(df_csv.columns) ## [&#39;id&#39;, &#39;name&#39;, &#39;city&#39;, &#39;state&#39;, &#39;region&#39;] df_csv.columns.to_list() ## [&#39;id&#39;, &#39;name&#39;, &#39;city&#39;, &#39;state&#39;, &#39;region&#39;] for cols in df_csv.columns: print(cols) ## id ## name ## city ## state ## region 2.1.3.3 data types in dataframe df_csv.dtypes ## id int64 ## name object ## city object ## state object ## region object ## dtype: object [types for types in df_csv.dtypes] ## [dtype(&#39;int64&#39;), dtype(&#39;O&#39;), dtype(&#39;O&#39;), dtype(&#39;O&#39;), dtype(&#39;O&#39;)] 2.1.3.4 index of the data frame df_csv[:5] ## id name city state region ## 0 102669 Alaska Pacific University Anchorage AK West ## 1 101648 Marion Military Institute Marion AL South ## 2 100830 Auburn University at Montgomery Montgomery AL South ## 3 101879 University of North Alabama Florence AL South ## 4 100858 Auburn University Auburn AL South df_csv.index ## RangeIndex(start=0, stop=100, step=1) for i in df_csv.index: if i &lt; 5: print(i) ## 0 ## 1 ## 2 ## 3 ## 4 2.1.3.5 assign a new index df = df_csv.copy() df.index = df.state df[:5] ## id name city state region ## state ## AK 102669 Alaska Pacific University Anchorage AK West ## AL 101648 Marion Military Institute Marion AL South ## AL 100830 Auburn University at Montgomery Montgomery AL South ## AL 101879 University of North Alabama Florence AL South ## AL 100858 Auburn University Auburn AL South 2.1.3.6 index to column df = df_csv.copy() df[&#39;index_column&#39;] = df.index df[:5] ## id name city state region \\ ## 0 102669 Alaska Pacific University Anchorage AK West ## 1 101648 Marion Military Institute Marion AL South ## 2 100830 Auburn University at Montgomery Montgomery AL South ## 3 101879 University of North Alabama Florence AL South ## 4 100858 Auburn University Auburn AL South ## ## index_column ## 0 0 ## 1 1 ## 2 2 ## 3 3 ## 4 4 calling keys() function: output is similar to columns attributes df_csv.keys() ## Index([&#39;id&#39;, &#39;name&#39;, &#39;city&#39;, &#39;state&#39;, &#39;region&#39;], dtype=&#39;object&#39;) column.values method returns an array of index. list(df_csv.columns.values) ## [&#39;id&#39;, &#39;name&#39;, &#39;city&#39;, &#39;state&#39;, &#39;region&#39;] Using tolist() method with values with given the list of columns. list(df_csv.columns.values.tolist()) ## [&#39;id&#39;, &#39;name&#39;, &#39;city&#39;, &#39;state&#39;, &#39;region&#39;] Using sorted() method : sorted() method will return the list of columns sorted in alphabetical order. sorted(df3) ## [&#39;var1&#39;, &#39;var2&#39;] 2.1.4 Create or add a new column You can create a new column in a pandas DataFrame based on the values of existing columns using various methods, such as assignment, the apply() function, or vectorized operations. Here are some examples: 2.1.5 Explore Data #recipes.head() 2.2 read data 2.2.1 csv file IBM sample data: I could not run with “https” because I did not have a certificate installed. So, I go on with “http” and it worked. data_link = &quot;http://s3-api.us-geo.objectstorage.softlayer.net/cf-courses-data/CognitiveClass/DS0103EN/labs/data/recipes.csv&quot; recipes = pd.read_csv(data_link) 2.2.2 xlsx file pandas.read_excel(io = path, sheet_name = 0, header = 0, names = None, index_col = None, usecols = None) This returns dataframe object. df = pd.read_excel(io = &quot;./data/segmentation.xlsx&quot;, sheet_name = &quot;sheet&quot;) df.head(n=5) ## respondent_id variety_of_choice electronics furniture \\ ## 0 1 8 6 6 ## 1 2 6 3 1 ## 2 3 6 1 2 ## 3 4 8 3 3 ## 4 5 4 6 3 ## ## quality_of_service low_prices return_policy professional income age ## 0 3 2 2 1 40 45 ## 1 4 7 8 0 20 41 ## 2 4 9 6 0 20 31 ## 3 4 8 7 1 30 37 ## 4 9 2 5 1 45 56 2.2.3 rename/assign new column names Renaming or assigning new column names in pandas DataFrame is a common operation, and there are several ways to accomplish it. Here are some examples with explanations: 2.2.3.1 Using the rename() method: The rename() method allows you to rename columns by specifying a dictionary where keys are the current column names and values are the new column names. df = df_csv.copy() df.rename(columns={&#39;id&#39;: &#39;NEW_ID&#39;}, inplace=True) df.columns.to_list() ## [&#39;NEW_ID&#39;, &#39;name&#39;, &#39;city&#39;, &#39;state&#39;, &#39;region&#39;] Setting inplace=True will modify the DataFrame in place, otherwise a new DataFrame with the renamed columns will be returned. 2.2.3.2 Direct assignment with dictionary: You can directly assign new column names to the columns attribute of the DataFrame using a dictionary. Note: you need to specify all the column names in the dictionary. df = df_csv[[&#39;name&#39;, &#39;state&#39;, &#39;id&#39;]].copy() df.columns = {&#39;MY_NAME&#39;: &#39;name&#39;, &#39;MY_STATE&#39;: &#39;state&#39;, &#39;id&#39;:&#39;id&#39;} df.columns.to_list() ## [&#39;MY_NAME&#39;, &#39;MY_STATE&#39;, &#39;id&#39;] 2.2.3.3 Using list assignment: You can directly assign a list of column names to the columns attribute of the DataFrame. Note: Make sure the length of the list matches the number of columns in the DataFrame. df = df_csv[[&#39;name&#39;, &#39;state&#39;]].copy() df.columns = [&#39;MY_NAME&#39;, &#39;MY_STATE&#39;] df.columns.to_list() ## [&#39;MY_NAME&#39;, &#39;MY_STATE&#39;] 2.2.3.4 Assigning new column names during DataFrame creation: You can provide the columns parameter when creating a DataFrame to specify the column names. df = pd.DataFrame(data, columns=[&#39;column1&#39;, &#39;column2&#39;, &#39;column3&#39;]) 2.2.3.5 to uppercase all column names df = df_csv.copy() df.columns = [x.upper() for x in df.columns] df.columns.to_list() ## [&#39;ID&#39;, &#39;NAME&#39;, &#39;CITY&#39;, &#39;STATE&#39;, &#39;REGION&#39;] 2.2.3.6 rename Renaming column names is a standard procedure most of the time. We may need to standardize column names, mostly make them clean. There is a nice link here. Lets create a sample data frame df = pd.DataFrame({&#39;A?la&#39;: [1,2,3,4], &#39;PYTHON&#39;: [&#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;], &#39;col 3&#39;: [&#39;1&#39;,&#39;1&#39;,&#39;b&#39;,&#39;b&#39;]}) df ## A?la PYTHON col 3 ## 0 1 a 1 ## 1 2 a 1 ## 2 3 a b ## 3 4 a b Method 1: Rename Specific Columns df.rename(columns = {&#39;PYTHON&#39;:&#39;Python&#39;}, inplace = False) ## A?la Python col 3 ## 0 1 a 1 ## 1 2 a 1 ## 2 3 a b ## 3 4 a b ### list column names list(df) ## [&#39;A?la&#39;, &#39;PYTHON&#39;, &#39;col 3&#39;] Method 2: Rename All Columns new_names = [&#39;new_name1&#39;, &#39;new_name2&#39;,&#39;new_name3&#39;] df.columns = new_names list(df) ## [&#39;new_name1&#39;, &#39;new_name2&#39;, &#39;new_name3&#39;] Method 3: Replace Specific Characters in Columns ### set problematic names problem_names = [&#39;VAR1$$$&#39;, &#39;var2&#39;,&#39;Var3###&#39;] df.columns = problem_names ### removing bad characters df.columns = df.columns.str.replace(&#39;$&#39;, &#39;&#39;, regex = True) df.columns = df.columns.str.replace(&#39;#&#39;, &#39;&#39;, regex = True) list(df) ## [&#39;VAR1&#39;, &#39;var2&#39;, &#39;Var3&#39;] clean column names Generally we expect clean columns to be: 1. short 2. meaningful 3. no space 4. no special character 5. probably lowercase ### set problematic names problem_names = [&#39;VAR $1&#39;, &#39;var #2&#39;,&#39;Var ? 3 &#39;] df.columns = problem_names ## Column names: remove white spaces and convert to lower case df.columns= df.columns.str.strip() ## Column names: convert to lower case df.columns = df.columns.str.lower() ## Column names: convert to lower case df = df.rename(columns = str.lower) ## removing bad characters df.columns = df.columns.str.replace(&#39;$&#39;, &#39;&#39;, regex = True) df.columns = df.columns.str.replace(&#39;#&#39;, &#39;&#39;, regex = True) df.columns = df.columns.str.replace(&#39;?&#39;, &#39;&#39;, regex = True) df.columns = df.columns.str.replace(&#39; &#39;, &#39;&#39;, regex = True) list(df) ## [&#39;var1&#39;, &#39;var2&#39;, &#39;var3&#39;] sometimes we need them to be uppercase ## Column names: convert to upper case df.columns = df.columns.str.upper() list(df) ## [&#39;VAR1&#39;, &#39;VAR2&#39;, &#39;VAR3&#39;] 2.2.4 Subsetting 2.2.4.1 by columns selected_cols = [&#39;id&#39;, &#39;name&#39;, &#39;city&#39;] df_csv[selected_cols] ## id name city ## 0 102669 Alaska Pacific University Anchorage ## 1 101648 Marion Military Institute Marion ## 2 100830 Auburn University at Montgomery Montgomery ## 3 101879 University of North Alabama Florence ## 4 100858 Auburn University Auburn ## .. ... ... ... ## 95 118888 Mills College Oakland ## 96 110097 Biola University La Mirada ## 97 117140 University of La Verne La Verne ## 98 125727 Westmont College Santa Barbara ## 99 123651 Vanguard University of Southern California Costa Mesa ## ## [100 rows x 3 columns] 2.2.4.2 Label based: df.loc[row_label, column_label] Selecting Rows and Columns by Labels: You can use df.loc[] to select rows and columns of a DataFrame using labels. The syntax is df.loc[row_label, column_label]. You can specify a single label or a list of labels for both rows and columns. row label is the index. # Select a single row and column df_csv.loc[1, &#39;name&#39;] ## &#39;Marion Military Institute&#39; # Select multiple rows and columns df_csv.loc[[0, 2, 4], [&#39;name&#39;, &#39;state&#39;]] ## name state ## 0 Alaska Pacific University AK ## 2 Auburn University at Montgomery AL ## 4 Auburn University AL # Select rows from &#39;row_label_start&#39; to &#39;row_label_end&#39; df_csv.loc[0:4] ## id name city state region ## 0 102669 Alaska Pacific University Anchorage AK West ## 1 101648 Marion Military Institute Marion AL South ## 2 100830 Auburn University at Montgomery Montgomery AL South ## 3 101879 University of North Alabama Florence AL South ## 4 100858 Auburn University Auburn AL South ## all same # df_csv.loc[0:4, ] # df_csv.loc[0:4, :] # Select rows where a condition is True df_csv.loc[df_csv[&#39;id&#39;] &lt; 101000] ## id name city state region ## 2 100830 Auburn University at Montgomery Montgomery AL South ## 4 100858 Auburn University Auburn AL South ## 5 100663 University of Alabama at Birmingham Birmingham AL South ## 9 100751 The University of Alabama Tuscaloosa AL South ## 11 100706 University of Alabama in Huntsville Huntsville AL South ## 18 100937 Birmingham Southern College Birmingham AL South ## 21 100724 Alabama State University Montgomery AL South ## 23 100654 Alabama A &amp; M University Normal AL South df = df_csv.copy() # Set a value for a specific row and column df.loc[10, &#39;name&#39;] = &#39;My University&#39; 2.2.4.3 Filtering Rows Based on a Single Condition: df = df_csv.copy() # Select rows where the &#39;column_name&#39; equals a specific value df[df[&#39;name&#39;] == &#39;Auburn University&#39;] ## id name city state region ## 4 100858 Auburn University Auburn AL South df[df.name == &#39;Auburn University&#39;] ## id name city state region ## 4 100858 Auburn University Auburn AL South 2.2.4.4 Filtering Rows Based on Multiple Conditions (AND): # Select rows where &#39;column1&#39; equals &#39;value1&#39; and &#39;column2&#39; equals &#39;value2&#39; df[(df.city == &#39;Birmingham&#39;) &amp; (df.state == &#39;AL&#39;)] ## id name city state region ## 5 100663 University of Alabama at Birmingham Birmingham AL South ## 7 102049 Samford University Birmingham AL South ## 10 102261 Southeastern Bible College Birmingham AL South ## 18 100937 Birmingham Southern College Birmingham AL South 2.2.5 copy When you use loc/iloc to create a subset of the DataFrame, you are also creating a view into the original DataFrame. Modifications to the subset will reflect in the original DataFrame, and vice versa. subset = df.loc[&#39;row_label1&#39;:&#39;row_label5&#39;, &#39;column_labelA&#39;:&#39;column_labelB&#39;] subset = df.iloc[0:5, 1:3] # Select rows 0 to 4 and columns 1 to 2 To create an independent copy of the DataFrame, you can use the copy() method. This ensures that modifications to the copied DataFrame do not affect the original DataFrame. copy_df = df.copy() "],["random.html", "Chapter 3 RANDOM", " Chapter 3 RANDOM i = int(input(&quot;sayi gir = &quot;)) for x in range(i+1) : y = x*5 print(x,&quot;x&quot;,5,&quot;=&quot;,y) "],["applications.html", "Chapter 4 Applications 4.1 Example one 4.2 Example two", " Chapter 4 Applications Some significant applications are demonstrated in this chapter. 4.1 Example one 4.2 Example two 4.2.1 no different "],["final-words.html", "Chapter 5 Final Words", " Chapter 5 Final Words We have finished a nice book. "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
